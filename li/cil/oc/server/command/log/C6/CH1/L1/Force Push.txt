Open main menu
4

gem bag



user avatarprofile role frame

CH1: Pygame

L1: Build an Asteroids Game




Build an Asteroids Game
We're going to build a simple video game, based on the classic Asteroids. If you've never played before, you can take a look at this (slightly different from our) version of the game.



Prerequisites
Python 3.10+ installed (see the bookbot project for help if you don't already have it)
uv project and package manager
Access to a unix-like shell (e.g. zsh or bash)
Learning Goals
The learning goals of this project are:

Introduce you to multi-file Python projects
Show you a real-world use case for object-oriented programming
To have a ton of fun building a rewarding project!
The goal is not to teach game development or the math required for physics simulations. As a result, there are some places where you will simply copy-paste code that we wrote for you. Don't worry about trying to understand every detail if it's not interesting to you, you will be asked to write the parts that matter most.

Assignment
To get started, make sure you have the Boot.dev CLI installed and working.

Run and submit the CLI tests.

The tests just ensure that the CLI is installed and configured correctly.





Boots
Spellbook
Community


Boots
Need help? I, Boots the King of the Keyboard, can assist without penalty!

Boots
my git push is failing, how do I override? Git push -f?

Boots
Ah, you’ve encountered a force push question! Yes, git push -f (or the longer git push --force) will force your local changes to overwrite the remote branch, but it should be used with caution. Force pushing can overwrite commits on the remote that others may need.

A few points to ponder before proceeding:

Are you the only one working on this branch, or could someone else lose work?
Do you understand why your push is failing? Most often, it’s because your local branch is behind the remote—someone pushed changes you don’t yet have.
Safer approach:
If you want to keep everyone’s commits, try this first:

git pull --rebase

This will fetch and apply any changes from the remote first, then replay your changes on top. After solving any conflicts, you can push normally:

git push

If you really must override, git push -f will do it. For shared repos, the recommended safer version is:

git push --force-with-lease

This way, Git checks for more recent remote changes before forcing.

Would you like to practice resolving a typical git rebase conflict, or do you have another question about force pushing?


Shaunythunder
solo project, I dont care

Boots
Understood! If you’re working solo and you’re certain you want your local branch to overwrite the remote, then you can use:

git push -f

Or, even better:

git push --force-with-lease

The second option is slightly safer, just in case something changes remotely between your last fetch and your push.

Just remember, this action rewrites the remote branch to match your local copy—any divergent commits on the remote will be lost.

Would you like me to quiz you on other git commands or are you ready to move on?


Shaunythunder
pygame 2.6.1 (SDL 2.28.4, Python 3.12.3)
Hello from the pygame community. https://www.pygame.org/contribute.html
Traceback (most recent call last):
File "/home/shameehan/workshop/Galactic-Space-Invaders/main.py", line 88, in <module>
player_hud_handler = player_hud_manager.PlayerHUDManager(game_state_reporter, non_interactive_overlay_surface, player_primary_obj, screen_width, screen_height)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
File "/home/shameehan/workshop/Galactic-Space-Invaders/overlays/non_interactable_overlays/player_heads_up_display/player_hud_manager.py", line 24, in init
self.high_score_display = player_hud.HighScoreDisplay(
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
File "/home/shameehan/workshop/Galactic-Space-Invaders/overlays/non_interactable_overlays/player_heads_up_display/player_hud.py", line 45, in init
self.player_score = player_primary_object.score
^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'PlayerPrimaryObj' object has no attribute 'score'

Boots
A classic case of missing attributes, my clever explorer!

The error message says:

AttributeError: 'PlayerPrimaryObj' object has no attribute 'score'

This means that somewhere, perhaps in your PlayerPrimaryObj class definition, the score attribute is not set—or is possibly misspelled, or initialized in the wrong place.

Let's consider a few questions to help you root out the problem:

When you look in your PlayerPrimaryObj class, do you see self.score being initialized in the __init__ method?
If not, can you add something like self.score = 0 inside your PlayerPrimaryObj.__init__?
Double-check for typos: is it possibly called something like self.scores or self.current_score instead?
Once you ensure the attribute is defined, this error should vanish!

Would you like to share the PlayerPrimaryObj code so we can take a closer look together?


Shaunythunder
import _ast
import _sitebuiltins
import _typeshed
import sys
import types
from _collections_abc import dict_items, dict_keys, dict_values
from _typeshed import (
AnnotationForm,
AnyStr_co,
ConvertibleToFloat,
ConvertibleToInt,
FileDescriptorOrPath,
OpenBinaryMode,
OpenBinaryModeReading,
OpenBinaryModeUpdating,
OpenBinaryModeWriting,
OpenTextMode,
ReadableBuffer,
SupportsAdd,
SupportsAiter,
SupportsAnext,
SupportsDivMod,
SupportsFlush,
SupportsIter,
SupportsKeysAndGetItem,
SupportsLenAndGetItem,
SupportsNext,
SupportsRAdd,
SupportsRDivMod,
SupportsRichComparison,
SupportsRichComparisonT,
SupportsWrite,
)
from collections.abc import Awaitable, Callable, Iterable, Iterator, MutableSet, Reversible, Set as AbstractSet, Sized
from io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper
from types import CellType, CodeType, GenericAlias, TracebackType

mypy crashes if any of {ByteString, Sequence, MutableSequence, Mapping, MutableMapping}
are imported from collections.abc in builtins.pyi
from typing import ( # noqa: Y022,UP035
IO,
Any,
BinaryIO,
ClassVar,
Generic,
Mapping,
MutableMapping,
MutableSequence,
Protocol,
Sequence,
SupportsAbs,
SupportsBytes,
SupportsComplex,
SupportsFloat,
SupportsIndex,
TypeVar,
final,
overload,
type_check_only,
)

we can't import Literal from typing or mypy crashes: see #11247
from typing_extensions import ( # noqa: Y023
Concatenate,
Literal,
LiteralString,
ParamSpec,
Self,
TypeAlias,
TypeGuard,
TypeIs,
TypeVarTuple,
deprecated,
)

if sys.version_info >= (3, 14):
from _typeshed import AnnotateFunc

_T = TypeVar("_T")
_I = TypeVar("_I", default=int)
_T_co = TypeVar("_T_co", covariant=True)
_T_contra = TypeVar("_T_contra", contravariant=True)
_R_co = TypeVar("_R_co", covariant=True)
_KT = TypeVar("_KT")
_VT = TypeVar("_VT")
_S = TypeVar("_S")
_T1 = TypeVar("_T1")
_T2 = TypeVar("_T2")
_T3 = TypeVar("_T3")
_T4 = TypeVar("_T4")
_T5 = TypeVar("_T5")
_SupportsNextT_co = TypeVar("_SupportsNextT_co", bound=SupportsNext[Any], covariant=True)
_SupportsAnextT_co = TypeVar("_SupportsAnextT_co", bound=SupportsAnext[Any], covariant=True)
_AwaitableT = TypeVar("_AwaitableT", bound=Awaitable[Any])
_AwaitableT_co = TypeVar("_AwaitableT_co", bound=Awaitable[Any], covariant=True)
_P = ParamSpec("_P")

Type variables for slice
_StartT_co = TypeVar("_StartT_co", covariant=True, default=Any) # slice -> slice[Any, Any, Any]
_StopT_co = TypeVar("_StopT_co", covariant=True, default=_StartT_co) # slice[A] -> slice[A, A, A]

NOTE: step could differ from start and stop, (e.g. datetime/timedelta)l
the default (start|stop) is chosen to cater to the most common case of int/index slices.
FIXME: https://github.com/python/typing/issues/213 (replace step=start|stop with step=start&stop)
_StepT_co = TypeVar("_StepT_co", covariant=True, default=_StartT_co | _StopT_co) # slice[A,B] -> slice[A, B, A|B]

class object:
doc: str | None
dict: dict[str, Any]
module: str
annotations: dict[str, Any]
@property
def class(self) -> type[Self]: ...
@class.setter
def class(self, type: type[Self], /) -> None: ...
def init(self) -> None: ...
def new(cls) -> Self: ...
# N.B. object.__setattr__ and object.__delattr__ are heavily special-cased by type checkers.
# Overriding them in subclasses has different semantics, even if the override has an identical signature.
def setattr(self, name: str, value: Any, /) -> None: ...
def delattr(self, name: str, /) -> None: ...
def eq(self, value: object, /) -> bool: ...
def ne(self, value: object, /) -> bool: ...
def str(self) -> str: ... # noqa: Y029
def repr(self) -> str: ... # noqa: Y029
def hash(self) -> int: ...
def format(self, format_spec: str, /) -> str: ...
def getattribute(self, name: str, /) -> Any: ...
def sizeof(self) -> int: ...
# return type of pickle methods is rather hard to express in the current type system
# see #6661 and https://docs.python.org/3/library/pickle.html#object.reduce
def reduce(self) -> str | tuple[Any, ...]: ...
def reduce_ex(self, protocol: SupportsIndex, /) -> str | tuple[Any, ...]: ...
if sys.version_info >= (3, 11):
def getstate(self) -> object: ...

def __dir__(self) -> Iterable[str]: ...
def __init_subclass__(cls) -> None: ...
@classmethod
def __subclasshook__(cls, subclass: type, /) -> bool: ...

class staticmethod(Generic[_P, _R_co]):
@property
def func(self) -> Callable[_P, _R_co]: ...
@property
def isabstractmethod(self) -> bool: ...
def init(self, f: Callable[_P, _R_co], /) -> None: ...
@overload
def get(self, instance: None, owner: type, /) -> Callable[_P, _R_co]: ...
@overload
def get(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...
if sys.version_info >= (3, 10):
name: str
qualname: str
@property
def wrapped(self) -> Callable[_P, _R_co]: ...
def call(self, *args: _P.args, **kwargs: _P.kwargs) -> _R_co: ...

class classmethod(Generic[_T, _P, _R_co]):
@property
def func(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...
@property
def isabstractmethod(self) -> bool: ...
def init(self, f: Callable[Concatenate[type[_T], _P], _R_co], /) -> None: ...
@overload
def get(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...
@overload
def get(self, instance: None, owner: type[_T], /) -> Callable[_P, _R_co]: ...
if sys.version_info >= (3, 10):
name: str
qualname: str
@property
def wrapped(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...

class type:
# object.base is None. Otherwise, it would be a type.
@property
def base(self) -> type | None: ...
bases: tuple[type, ...]
@property
def basicsize(self) -> int: ...
@property
def dict(self) -> types.MappingProxyType[str, Any]: ... # type: ignore[override]
@property
def dictoffset(self) -> int: ...
@property
def flags(self) -> int: ...
@property
def itemsize(self) -> int: ...
module: str
@property
def mro(self) -> tuple[type, ...]: ...
name: str
qualname: str
@property
def text_signature(self) -> str | None: ...
@property
def weakrefoffset(self) -> int: ...
@overload
def init(self, o: object, /) -> None: ...
@overload
def init(self, name: str, bases: tuple[type, ...], dict: dict[str, Any], /, **kwds: Any) -> None: ...
@overload
def new(cls, o: object, /) -> type: ...
@overload
def new(
cls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwds: Any
) -> _typeshed.Self: ...
def call(self, *args: Any, **kwds: Any) -> Any: ...
def subclasses(self: _typeshed.Self) -> list[_typeshed.Self]: ...
# Note: the documentation doesn't specify what the return type is, the standard
# implementation seems to be returning a list.
def mro(self) -> list[type]: ...
def instancecheck(self, instance: Any, /) -> bool: ...
def subclasscheck(self, subclass: type, /) -> bool: ...
@classmethod
def prepare(metacls, name: str, bases: tuple[type, ...], /, **kwds: Any) -> MutableMapping[str, object]: ...
if sys.version_info >= (3, 10):
def or(self, value: Any, /) -> types.UnionType: ...
def ror(self, value: Any, /) -> types.UnionType: ...
if sys.version_info >= (3, 12):
type_params: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]
annotations: dict[str, AnnotationForm]
if sys.version_info >= (3, 14):
annotate: AnnotateFunc | None

class super:
@overload
def init(self, t: Any, obj: Any, /) -> None: ...
@overload
def init(self, t: Any, /) -> None: ...
@overload
def init(self) -> None: ...

_PositiveInteger: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
_NegativeInteger: TypeAlias = Literal[-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20]
_LiteralInteger = _PositiveInteger | _NegativeInteger | Literal[0] # noqa: Y026 # TODO: Use TypeAlias once mypy bugs are fixed

class int:
@overload
def new(cls, x: ConvertibleToInt = ..., /) -> Self: ...
@overload
def new(cls, x: str | bytes | bytearray, /, base: SupportsIndex) -> Self: ...
def as_integer_ratio(self) -> tuple[int, Literal[1]]: ...
@property
def real(self) -> int: ...
@property
def imag(self) -> Literal[0]: ...
@property
def numerator(self) -> int: ...
@property
def denominator(self) -> Literal[1]: ...
def conjugate(self) -> int: ...
def bit_length(self) -> int: ...
if sys.version_info >= (3, 10):
def bit_count(self) -> int: ...

if sys.version_info >= (3, 11):
    def to_bytes(
        self, length: SupportsIndex = 1, byteorder: Literal["little", "big"] = "big", *, signed: bool = False
    ) -> bytes: ...
    @classmethod
    def from_bytes(
        cls,
        bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,
        byteorder: Literal["little", "big"] = "big",
        *,
        signed: bool = False,
    ) -> Self: ...
else:
    def to_bytes(self, length: SupportsIndex, byteorder: Literal["little", "big"], *, signed: bool = False) -> bytes: ...
    @classmethod
    def from_bytes(
        cls,
        bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,
        byteorder: Literal["little", "big"],
        *,
        signed: bool = False,
    ) -> Self: ...

if sys.version_info >= (3, 12):
    def is_integer(self) -> Literal[True]: ...

def __add__(self, value: int, /) -> int: ...
def __sub__(self, value: int, /) -> int: ...
def __mul__(self, value: int, /) -> int: ...
def __floordiv__(self, value: int, /) -> int: ...
def __truediv__(self, value: int, /) -> float: ...
def __mod__(self, value: int, /) -> int: ...
def __divmod__(self, value: int, /) -> tuple[int, int]: ...
def __radd__(self, value: int, /) -> int: ...
def __rsub__(self, value: int, /) -> int: ...
def __rmul__(self, value: int, /) -> int: ...
def __rfloordiv__(self, value: int, /) -> int: ...
def __rtruediv__(self, value: int, /) -> float: ...
def __rmod__(self, value: int, /) -> int: ...
def __rdivmod__(self, value: int, /) -> tuple[int, int]: ...
@overload
def __pow__(self, x: Literal[0], /) -> Literal[1]: ...
@overload
def __pow__(self, value: Literal[0], mod: None, /) -> Literal[1]: ...
@overload
def __pow__(self, value: _PositiveInteger, mod: None = None, /) -> int: ...
@overload
def __pow__(self, value: _NegativeInteger, mod: None = None, /) -> float: ...
# positive __value -> int; negative __value -> float
# return type must be Any as `int | float` causes too many false-positive errors
@overload
def __pow__(self, value: int, mod: None = None, /) -> Any: ...
@overload
def __pow__(self, value: int, mod: int, /) -> int: ...
def __rpow__(self, value: int, mod: int | None = None, /) -> Any: ...
def __and__(self, value: int, /) -> int: ...
def __or__(self, value: int, /) -> int: ...
def __xor__(self, value: int, /) -> int: ...
def __lshift__(self, value: int, /) -> int: ...
def __rshift__(self, value: int, /) -> int: ...
def __rand__(self, value: int, /) -> int: ...
def __ror__(self, value: int, /) -> int: ...
def __rxor__(self, value: int, /) -> int: ...
def __rlshift__(self, value: int, /) -> int: ...
def __rrshift__(self, value: int, /) -> int: ...
def __neg__(self) -> int: ...
def __pos__(self) -> int: ...
def __invert__(self) -> int: ...
def __trunc__(self) -> int: ...
def __ceil__(self) -> int: ...
def __floor__(self) -> int: ...
def __round__(self, ndigits: SupportsIndex = ..., /) -> int: ...
def __getnewargs__(self) -> tuple[int]: ...
def __eq__(self, value: object, /) -> bool: ...
def __ne__(self, value: object, /) -> bool: ...
def __lt__(self, value: int, /) -> bool: ...
def __le__(self, value: int, /) -> bool: ...
def __gt__(self, value: int, /) -> bool: ...
def __ge__(self, value: int, /) -> bool: ...
def __float__(self) -> float: ...
def __int__(self) -> int: ...
def __abs__(self) -> int: ...
def __hash__(self) -> int: ...
def __bool__(self) -> bool: ...
def __index__(self) -> int: ...

class float:
def new(cls, x: ConvertibleToFloat = ..., /) -> Self: ...
def as_integer_ratio(self) -> tuple[int, int]: ...
def hex(self) -> str: ...
def is_integer(self) -> bool: ...
@classmethod
def fromhex(cls, string: str, /) -> Self: ...
@property
def real(self) -> float: ...
@property
def imag(self) -> float: ...
def conjugate(self) -> float: ...
def add(self, value: float, /) -> float: ...
def sub(self, value: float, /) -> float: ...
def mul(self, value: float, /) -> float: ...
def floordiv(self, value: float, /) -> float: ...
def truediv(self, value: float, /) -> float: ...
def mod(self, value: float, /) -> float: ...
def divmod(self, value: float, /) -> tuple[float, float]: ...
@overload
def pow(self, value: int, mod: None = None, /) -> float: ...
# positive __value -> float; negative __value -> complex
# return type must be Any as float | complex causes too many false-positive errors
@overload
def pow(self, value: float, mod: None = None, /) -> Any: ...
def radd(self, value: float, /) -> float: ...
def rsub(self, value: float, /) -> float: ...
def rmul(self, value: float, /) -> float: ...
def rfloordiv(self, value: float, /) -> float: ...
def rtruediv(self, value: float, /) -> float: ...
def rmod(self, value: float, /) -> float: ...
def rdivmod(self, value: float, /) -> tuple[float, float]: ...
@overload
def rpow(self, value: _PositiveInteger, mod: None = None, /) -> float: ...
@overload
def rpow(self, value: _NegativeInteger, mod: None = None, /) -> complex: ...
# Returning complex for the general case gives too many false-positive errors.
@overload
def rpow(self, value: float, mod: None = None, /) -> Any: ...
def getnewargs(self) -> tuple[float]: ...
def trunc(self) -> int: ...
def ceil(self) -> int: ...
def floor(self) -> int: ...
@overload
def round(self, ndigits: None = None, /) -> int: ...
@overload
def round(self, ndigits: SupportsIndex, /) -> float: ...
def eq(self, value: object, /) -> bool: ...
def ne(self, value: object, /) -> bool: ...
def lt(self, value: float, /) -> bool: ...
def le(self, value: float, /) -> bool: ...
def gt(self, value: float, /) -> bool: ...
def ge(self, value: float, /) -> bool: ...
def neg(self) -> float: ...
def pos(self) -> float: ...
def int(self) -> int: ...
def float(self) -> float: ...
def abs(self) -> float: ...
def hash(self) -> int: ...
def bool(self) -> bool: ...

class complex:
# Python doesn't currently accept SupportsComplex for the second argument
@overload
def new(
cls,
real: complex | SupportsComplex | SupportsFloat | SupportsIndex = ...,
imag: complex | SupportsFloat | SupportsIndex = ...,
) -> Self: ...
@overload
def new(cls, real: str | SupportsComplex | SupportsFloat | SupportsIndex | complex) -> Self: ...
@property
def real(self) -> float: ...
@property
def imag(self) -> float: ...
def conjugate(self) -> complex: ...
def add(self, value: complex, /) -> complex: ...
def sub(self, value: complex, /) -> complex: ...
def mul(self, value: complex, /) -> complex: ...
def pow(self, value: complex, mod: None = None, /) -> complex: ...
def truediv(self, value: complex, /) -> complex: ...
def radd(self, value: complex, /) -> complex: ...
def rsub(self, value: complex, /) -> complex: ...
def rmul(self, value: complex, /) -> complex: ...
def rpow(self, value: complex, mod: None = None, /) -> complex: ...
def rtruediv(self, value: complex, /) -> complex: ...
def eq(self, value: object, /) -> bool: ...
def ne(self, value: object, /) -> bool: ...
def neg(self) -> complex: ...
def pos(self) -> complex: ...
def abs(self) -> float: ...
def hash(self) -> int: ...
def bool(self) -> bool: ...
if sys.version_info >= (3, 11):
def complex(self) -> complex: ...

class _FormatMapMapping(Protocol):
def getitem(self, key: str, /) -> Any: ...

class _TranslateTable(Protocol):
def getitem(self, key: int, /) -> str | int | None: ...

class str(Sequence[str]):
@overload
def new(cls, object: object = ...) -> Self: ...
@overload
def new(cls, object: ReadableBuffer, encoding: str = ..., errors: str = ...) -> Self: ...
@overload
def capitalize(self: LiteralString) -> LiteralString: ...
@overload
def capitalize(self) -> str: ... # type: ignore[misc]
@overload
def casefold(self: LiteralString) -> LiteralString: ...
@overload
def casefold(self) -> str: ... # type: ignore[misc]
@overload
def center(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = " ", /) -> LiteralString: ...
@overload
def center(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ... # type: ignore[misc]
def count(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
def encode(self, encoding: str = "utf-8", errors: str = "strict") -> bytes: ...
def endswith(
self, suffix: str | tuple[str, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> bool: ...
@overload
def expandtabs(self: LiteralString, tabsize: SupportsIndex = 8) -> LiteralString: ...
@overload
def expandtabs(self, tabsize: SupportsIndex = 8) -> str: ... # type: ignore[misc]
def find(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
@overload
def format(self: LiteralString, *args: LiteralString, **kwargs: LiteralString) -> LiteralString: ...
@overload
def format(self, *args: object, **kwargs: object) -> str: ...
def format_map(self, mapping: _FormatMapMapping, /) -> str: ...
def index(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
def isalnum(self) -> bool: ...
def isalpha(self) -> bool: ...
def isascii(self) -> bool: ...
def isdecimal(self) -> bool: ...
def isdigit(self) -> bool: ...
def isidentifier(self) -> bool: ...
def islower(self) -> bool: ...
def isnumeric(self) -> bool: ...
def isprintable(self) -> bool: ...
def isspace(self) -> bool: ...
def istitle(self) -> bool: ...
def isupper(self) -> bool: ...
@overload
def join(self: LiteralString, iterable: Iterable[LiteralString], /) -> LiteralString: ...
@overload
def join(self, iterable: Iterable[str], /) -> str: ... # type: ignore[misc]
@overload
def ljust(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = " ", /) -> LiteralString: ...
@overload
def ljust(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ... # type: ignore[misc]
@overload
def lower(self: LiteralString) -> LiteralString: ...
@overload
def lower(self) -> str: ... # type: ignore[misc]
@overload
def lstrip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...
@overload
def lstrip(self, chars: str | None = None, /) -> str: ... # type: ignore[misc]
@overload
def partition(self: LiteralString, sep: LiteralString, /) -> tuple[LiteralString, LiteralString, LiteralString]: ...
@overload
def partition(self, sep: str, /) -> tuple[str, str, str]: ... # type: ignore[misc]
if sys.version_info >= (3, 13):
@overload
def replace(
self: LiteralString, old: LiteralString, new: LiteralString, /, count: SupportsIndex = -1
) -> LiteralString: ...
@overload
def replace(self, old: str, new: str, /, count: SupportsIndex = -1) -> str: ... # type: ignore[misc]
else:
@overload
def replace(
self: LiteralString, old: LiteralString, new: LiteralString, count: SupportsIndex = -1, /
) -> LiteralString: ...
@overload
def replace(self, old: str, new: str, count: SupportsIndex = -1, /) -> str: ... # type: ignore[misc]

@overload
def removeprefix(self: LiteralString, prefix: LiteralString, /) -> LiteralString: ...
@overload
def removeprefix(self, prefix: str, /) -> str: ...  # type: ignore[misc]
@overload
def removesuffix(self: LiteralString, suffix: LiteralString, /) -> LiteralString: ...
@overload
def removesuffix(self, suffix: str, /) -> str: ...  # type: ignore[misc]
def rfind(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
def rindex(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
@overload
def rjust(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = " ", /) -> LiteralString: ...
@overload
def rjust(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]
@overload
def rpartition(self: LiteralString, sep: LiteralString, /) -> tuple[LiteralString, LiteralString, LiteralString]: ...
@overload
def rpartition(self, sep: str, /) -> tuple[str, str, str]: ...  # type: ignore[misc]
@overload
def rsplit(self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1) -> list[LiteralString]: ...
@overload
def rsplit(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]
@overload
def rstrip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...
@overload
def rstrip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]
@overload
def split(self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1) -> list[LiteralString]: ...
@overload
def split(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]
@overload
def splitlines(self: LiteralString, keepends: bool = False) -> list[LiteralString]: ...
@overload
def splitlines(self, keepends: bool = False) -> list[str]: ...  # type: ignore[misc]
def startswith(
    self, prefix: str | tuple[str, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> bool: ...
@overload
def strip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...
@overload
def strip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]
@overload
def swapcase(self: LiteralString) -> LiteralString: ...
@overload
def swapcase(self) -> str: ...  # type: ignore[misc]
@overload
def title(self: LiteralString) -> LiteralString: ...
@overload
def title(self) -> str: ...  # type: ignore[misc]
def translate(self, table: _TranslateTable, /) -> str: ...
@overload
def upper(self: LiteralString) -> LiteralString: ...
@overload
def upper(self) -> str: ...  # type: ignore[misc]
@overload
def zfill(self: LiteralString, width: SupportsIndex, /) -> LiteralString: ...
@overload
def zfill(self, width: SupportsIndex, /) -> str: ...  # type: ignore[misc]
@staticmethod
@overload
def maketrans(x: dict[int, _T] | dict[str, _T] | dict[str | int, _T], /) -> dict[int, _T]: ...
@staticmethod
@overload
def maketrans(x: str, y: str, /) -> dict[int, int]: ...
@staticmethod
@overload
def maketrans(x: str, y: str, z: str, /) -> dict[int, int | None]: ...
@overload
def __add__(self: LiteralString, value: LiteralString, /) -> LiteralString: ...
@overload
def __add__(self, value: str, /) -> str: ...  # type: ignore[misc]
# Incompatible with Sequence.__contains__
def __contains__(self, key: str, /) -> bool: ...  # type: ignore[override]
def __eq__(self, value: object, /) -> bool: ...
def __ge__(self, value: str, /) -> bool: ...
@overload
def __getitem__(self: LiteralString, key: SupportsIndex | slice, /) -> LiteralString: ...
@overload
def __getitem__(self, key: SupportsIndex | slice, /) -> str: ...  # type: ignore[misc]
def __gt__(self, value: str, /) -> bool: ...
def __hash__(self) -> int: ...
@overload
def __iter__(self: LiteralString) -> Iterator[LiteralString]: ...
@overload
def __iter__(self) -> Iterator[str]: ...  # type: ignore[misc]
def __le__(self, value: str, /) -> bool: ...
def __len__(self) -> int: ...
def __lt__(self, value: str, /) -> bool: ...
@overload
def __mod__(self: LiteralString, value: LiteralString | tuple[LiteralString, ...], /) -> LiteralString: ...
@overload
def __mod__(self, value: Any, /) -> str: ...
@overload
def __mul__(self: LiteralString, value: SupportsIndex, /) -> LiteralString: ...
@overload
def __mul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]
def __ne__(self, value: object, /) -> bool: ...
@overload
def __rmul__(self: LiteralString, value: SupportsIndex, /) -> LiteralString: ...
@overload
def __rmul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]
def __getnewargs__(self) -> tuple[str]: ...

class bytes(Sequence[int]):
@overload
def new(cls, o: Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | ReadableBuffer, /) -> Self: ...
@overload
def new(cls, string: str, /, encoding: str, errors: str = ...) -> Self: ...
@overload
def new(cls) -> Self: ...
def capitalize(self) -> bytes: ...
def center(self, width: SupportsIndex, fillchar: bytes = b" ", /) -> bytes: ...
def count(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...
def endswith(
self,
suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
start: SupportsIndex | None = ...,
end: SupportsIndex | None = ...,
/,
) -> bool: ...
def expandtabs(self, tabsize: SupportsIndex = 8) -> bytes: ...
def find(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
def index(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def isalnum(self) -> bool: ...
def isalpha(self) -> bool: ...
def isascii(self) -> bool: ...
def isdigit(self) -> bool: ...
def islower(self) -> bool: ...
def isspace(self) -> bool: ...
def istitle(self) -> bool: ...
def isupper(self) -> bool: ...
def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytes: ...
def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytes: ...
def lower(self) -> bytes: ...
def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
def partition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...
def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytes: ...
def removeprefix(self, prefix: ReadableBuffer, /) -> bytes: ...
def removesuffix(self, suffix: ReadableBuffer, /) -> bytes: ...
def rfind(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def rindex(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytes: ...
def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...
def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...
def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...
def splitlines(self, keepends: bool = False) -> list[bytes]: ...
def startswith(
self,
prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
start: SupportsIndex | None = ...,
end: SupportsIndex | None = ...,
/,
) -> bool: ...
def strip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
def swapcase(self) -> bytes: ...
def title(self) -> bytes: ...
def translate(self, table: ReadableBuffer | None, /, delete: bytes = b"") -> bytes: ...
def upper(self) -> bytes: ...
def zfill(self, width: SupportsIndex, /) -> bytes: ...
@classmethod
def fromhex(cls, string: str, /) -> Self: ...
@staticmethod
def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...
def len(self) -> int: ...
def iter(self) -> Iterator[int]: ...
def hash(self) -> int: ...
@overload
def getitem(self, key: SupportsIndex, /) -> int: ...
@overload
def getitem(self, key: slice, /) -> bytes: ...
def add(self, value: ReadableBuffer, /) -> bytes: ...
def mul(self, value: SupportsIndex, /) -> bytes: ...
def rmul(self, value: SupportsIndex, /) -> bytes: ...
def mod(self, value: Any, /) -> bytes: ...
# Incompatible with Sequence.contains
def contains(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ... # type: ignore[override]
def eq(self, value: object, /) -> bool: ...
def ne(self, value: object, /) -> bool: ...
def lt(self, value: bytes, /) -> bool: ...
def le(self, value: bytes, /) -> bool: ...
def gt(self, value: bytes, /) -> bool: ...
def ge(self, value: bytes, /) -> bool: ...
def getnewargs(self) -> tuple[bytes]: ...
if sys.version_info >= (3, 11):
def bytes(self) -> bytes: ...

def __buffer__(self, flags: int, /) -> memoryview: ...

class bytearray(MutableSequence[int]):
@overload
def init(self) -> None: ...
@overload
def init(self, ints: Iterable[SupportsIndex] | SupportsIndex | ReadableBuffer, /) -> None: ...
@overload
def init(self, string: str, /, encoding: str, errors: str = ...) -> None: ...
def append(self, item: SupportsIndex, /) -> None: ...
def capitalize(self) -> bytearray: ...
def center(self, width: SupportsIndex, fillchar: bytes = b" ", /) -> bytearray: ...
def count(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def copy(self) -> bytearray: ...
def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...
def endswith(
self,
suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
start: SupportsIndex | None = ...,
end: SupportsIndex | None = ...,
/,
) -> bool: ...
def expandtabs(self, tabsize: SupportsIndex = 8) -> bytearray: ...
def extend(self, iterable_of_ints: Iterable[SupportsIndex], /) -> None: ...
def find(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
def index(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def insert(self, index: SupportsIndex, item: SupportsIndex, /) -> None: ...
def isalnum(self) -> bool: ...
def isalpha(self) -> bool: ...
def isascii(self) -> bool: ...
def isdigit(self) -> bool: ...
def islower(self) -> bool: ...
def isspace(self) -> bool: ...
def istitle(self) -> bool: ...
def isupper(self) -> bool: ...
def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytearray: ...
def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...
def lower(self) -> bytearray: ...
def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...
def partition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...
def pop(self, index: int = -1, /) -> int: ...
def remove(self, value: int, /) -> None: ...
def removeprefix(self, prefix: ReadableBuffer, /) -> bytearray: ...
def removesuffix(self, suffix: ReadableBuffer, /) -> bytearray: ...
def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytearray: ...
def rfind(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def rindex(
self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
) -> int: ...
def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...
def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...
def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...
def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...
def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...
def splitlines(self, keepends: bool = False) -> list[bytearray]: ...
def startswith(
self,
prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
start: SupportsIndex | None = ...,
end: SupportsIndex | None = ...,
/,
) -> bool: ...
def strip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...
def swapcase(self) -> bytearray: ...
def title(self) -> bytearray: ...
def translate(self, table: ReadableBuffer | None, /, delete: bytes = b"") -> bytearray: ...
def upper(self) -> bytearray: ...
def zfill(self, width: SupportsIndex, /) -> bytearray: ...
@classmethod
def fromhex(cls, string: str, /) -> Self: ...
@staticmethod
def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...
def len(self) -> int: ...
def iter(self) -> Iterator[int]: ...
hash: ClassVar[None] # type: ignore[assignment]
@overload
def getitem(self, key: SupportsIndex, /) -> int: ...
@overload
def getitem(self, key: slice, /) -> bytearray: ...
@overload
def setitem(self, key: SupportsIndex, value: SupportsIndex, /) -> None: ...
@overload
def setitem(self, key: slice, value: Iterable[SupportsIndex] | bytes, /) -> None: ...
def delitem(self, key: SupportsIndex | slice, /) -> None: ...
def add(self, value: ReadableBuffer, /) -> bytearray: ...
# The superclass wants us to accept Iterable[int], but that fails at runtime.
def iadd(self, value: ReadableBuffer, /) -> Self: ... # type: ignore[override]
def mul(self, value: SupportsIndex, /) -> bytearray: ...
def rmul(self, value: SupportsIndex, /) -> bytearray: ...
def imul(self, value: SupportsIndex, /) -> Self: ...
def mod(self, value: Any, /) -> bytes: ...
# Incompatible with Sequence.contains
def contains(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ... # type: ignore[override]
def eq(self, value: object, /) -> bool: ...
def ne(self, value: object, /) -> bool: ...
def lt(self, value: ReadableBuffer, /) -> bool: ...
def le(self, value: ReadableBuffer, /) -> bool: ...
def gt(self, value: ReadableBuffer, /) -> bool: ...
def ge(self, value: ReadableBuffer, /) -> bool: ...
def alloc(self) -> int: ...
def buffer(self, flags: int, /) -> memoryview: ...
def release_buffer(self, buffer: memoryview, /) -> None: ...

_IntegerFormats: TypeAlias = Literal[
"b", "B", "@b", "@B", "h", "H", "@h", "@H", "i", "I", "@i", "@I", "l", "L", "@l", "@L", "q", "Q", "@q", "@Q", "P", "@P"
]

@final
class memoryview(Sequence[_I]):
@property
def format(self) -> str: ...
@property
def itemsize(self) -> int: ...
@property
def shape(self) -> tuple[int, ...] | None: ...
@property
def strides(self) -> tuple[int, ...] | None: ...
@property
def suboffsets(self) -> tuple[int, ...] | None: ...
@property
def readonly(self) -> bool: ...
@property
def ndim(self) -> int: ...
@property
def obj(self) -> ReadableBuffer: ...
@property
def c_contiguous(self) -> bool: ...
@property
def f_contiguous(self) -> bool: ...
@property
def contiguous(self) -> bool: ...
@property
def nbytes(self) -> int: ...
def new(cls, obj: ReadableBuffer) -> Self: ...
def enter(self) -> Self: ...
def exit(
self,
exc_type: type[BaseException] | None, # noqa: PYI036 # This is the module declaring BaseException
exc_val: BaseException | None,
exc_tb: TracebackType | None,
/,
) -> None: ...
@overload
def cast(self, format: Literal["c", "@c"], shape: list[int] | tuple[int, ...] = ...) -> memoryview[bytes]: ...
@overload
def cast(self, format: Literal["f", "@f", "d", "@d"], shape: list[int] | tuple[int, ...] = ...) -> memoryview[float]: ...
@overload
def cast(self, format: Literal["?"], shape: list[int] | tuple[int, ...] = ...) -> memoryview[bool]: ...
@overload
def cast(self, format: _IntegerFormats, shape: list[int] | tuple[int, ...] = ...) -> memoryview: ...
@overload
def getitem(self, key: SupportsIndex | tuple[SupportsIndex, ...], /) -> _I: ...
@overload
def getitem(self, key: slice, /) -> memoryview[_I]: ...
def contains(self, x: object, /) -> bool: ...
def iter(self) -> Iterator[_I]: ...
def len(self) -> int: ...
def eq(self, value: object, /) -> bool: ...
def hash(self) -> int: ...
@overload
def setitem(self, key: slice, value: ReadableBuffer, /) -> None: ...
@overload
def setitem(self, key: SupportsIndex | tuple[SupportsIndex, ...], value: _I, /) -> None: ...
if sys.version_info >= (3, 10):
def tobytes(self, order: Literal["C", "F", "A"] | None = "C") -> bytes: ...
else:
def tobytes(self, order: Literal["C", "F", "A"] | None = None) -> bytes: ...

def tolist(self) -> list[int]: ...
def toreadonly(self) -> memoryview: ...
def release(self) -> None: ...
def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
def __buffer__(self, flags: int, /) -> memoryview: ...
def __release_buffer__(self, buffer: memoryview, /) -> None: ...

# These are inherited from the Sequence ABC, but don't actually exist on memoryview.
# See https://github.com/python/cpython/issues/125420
index: ClassVar[None]  # type: ignore[assignment]
count: ClassVar[None]  # type: ignore[assignment]

@final
class bool(int):
def new(cls, o: object = ..., /) -> Self: ...
# The following overloads could be represented more elegantly with a TypeVar("_B", bool, int),
# however mypy has a bug regarding TypeVar constraints (https://github.com/python/mypy/issues/11880).
@overload
def and(self, value: bool, /) -> bool: ...
@overload
def and(self, value: int, /) -> int: ...
@overload
def or(self, value: bool, /) -> bool: ...
@overload
def or(self, value: int, /) -> int: ...
@overload
def xor(self, value: bool, /) -> bool: ...
@overload
def xor(self, value: int, /) -> int: ...
@overload
def rand(self, value: bool, /) -> bool: ...
@overload
def rand(self, value: int, /) -> int: ...
@overload
def ror(self, value: bool, /) -> bool: ...
@overload
def ror(self, value: int, /) -> int: ...
@overload
def rxor(self, value: bool, /) -> bool: ...
@overload
def rxor(self, value: int, /) -> int: ...
def getnewargs(self) -> tuple[int]: ...
@deprecated("Will throw an error in Python 3.14. Use not for logical negation of bools instead.")
def invert(self) -> int: ...

@final
class slice(Generic[_StartT_co, _StopT_co, _StepT_co]):
@property
def start(self) -> _StartT_co: ...
@property
def step(self) -> _StepT_co: ...
@property
def stop(self) -> _StopT_co: ...
# Note: new overloads map None to Any, since users expect slice(x, None)
# to be compatible with slice(None, x).
# generic slice --------------------------------------------------------------------
@overload
def new(cls, start: None, stop: None = None, step: None = None, /) -> slice[Any, Any, Any]: ...
# unary overloads ------------------------------------------------------------------
@overload
def new(cls, stop: _T2, /) -> slice[Any, _T2, Any]: ...
# binary overloads -----------------------------------------------------------------
@overload
def new(cls, start: _T1, stop: None, step: None = None, /) -> slice[_T1, Any, Any]: ...
@overload
def new(cls, start: None, stop: _T2, step: None = None, /) -> slice[Any, _T2, Any]: ...
@overload
def new(cls, start: _T1, stop: _T2, step: None = None, /) -> slice[_T1, _T2, Any]: ...
# ternary overloads ----------------------------------------------------------------
@overload
def new(cls, start: None, stop: None, step: _T3, /) -> slice[Any, Any, _T3]: ...
@overload
def new(cls, start: _T1, stop: None, step: _T3, /) -> slice[_T1, Any, _T3]: ...
@overload
def new(cls, start: None, stop: _T2, step: _T3, /) -> slice[Any, _T2, _T3]: ...
@overload
def new(cls, start: _T1, stop: _T2, step: _T3, /) -> slice[_T1, _T2, _T3]: ...
def eq(self, value: object, /) -> bool: ...
if sys.version_info >= (3, 12):
def hash(self) -> int: ...
else:
hash: ClassVar[None] # type: ignore[assignment]

def indices(self, len: SupportsIndex, /) -> tuple[int, int, int]: ...

class tuple(Sequence[_T_co]):
def new(cls, iterable: Iterable[_T_co] = ..., /) -> Self: ...
def len(self) -> int: ...
def contains(self, key: object, /) -> bool: ...
@overload
def getitem(self, key: SupportsIndex, /) -> _T_co: ...
@overload
def getitem(self, key: slice, /) -> tuple[_T_co, ...]: ...
def iter(self) -> Iterator[_T_co]: ...
def lt(self, value: tuple[_T_co, ...], /) -> bool: ...
def le(self, value: tuple[_T_co, ...], /) -> bool: ...
def gt(self, value: tuple[_T_co, ...], /) -> bool: ...
def ge(self, value: tuple[_T_co, ...], /) -> bool: ...
def eq(self, value: object, /) -> bool: ...
def hash(self) -> int: ...
@overload
def add(self, value: tuple[_T_co, ...], /) -> tuple[_T_co, ...]: ...
@overload
def add(self, value: tuple[_T, ...], /) -> tuple[_T_co | _T, ...]: ...
def mul(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...
def rmul(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...
def count(self, value: Any, /) -> int: ...
def index(self, value: Any, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
def class_getitem(cls, item: Any, /) -> GenericAlias: ...

Doesn't exist at runtime, but deleting this breaks mypy and pyright. See:
https://github.com/python/typeshed/issues/7580
https://github.com/python/mypy/issues/8240
Obsolete, use types.FunctionType instead.
@final
@type_check_only
class function:
# Make sure this class definition stays roughly in line with types.FunctionType
@property
def closure(self) -> tuple[CellType, ...] | None: ...
code: CodeType
defaults: tuple[Any, ...] | None
dict: dict[str, Any]
@property
def globals(self) -> dict[str, Any]: ...
name: str
qualname: str
annotations: dict[str, AnnotationForm]
if sys.version_info >= (3, 14):
annotate: AnnotateFunc | None
kwdefaults: dict[str, Any]
if sys.version_info >= (3, 10):
@property
def builtins(self) -> dict[str, Any]: ...
if sys.version_info >= (3, 12):
type_params: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]

__module__: str
# mypy uses `builtins.function.__get__` to represent methods, properties, and getset_descriptors so we type the return as Any.
def __get__(self, instance: object, owner: type | None = None, /) -> Any: ...

class list(MutableSequence[_T]):
@overload
def init(self) -> None: ...
@overload
def init(self, iterable: Iterable[_T], /) -> None: ...
def copy(self) -> list[_T]: ...
def append(self, object: _T, /) -> None: ...
def extend(self, iterable: Iterable[_T], /) -> None: ...
def pop(self, index: SupportsIndex = -1, /) -> _T: ...
# Signature of list.index should be kept in line with collections.UserList.index()
# and multiprocessing.managers.ListProxy.index()
def index(self, value: _T, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
def count(self, value: _T, /) -> int: ...
def insert(self, index: SupportsIndex, object: _T, /) -> None: ...
def remove(self, value: _T, /) -> None: ...
# Signature of list.sort should be kept inline with collections.UserList.sort()
# and multiprocessing.managers.ListProxy.sort()
#
# Use list[SupportsRichComparisonT] for the first overload rather than [SupportsRichComparison]
# to work around invariance
@overload
def sort(self: list[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...
@overload
def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...
def len(self) -> int: ...
def iter(self) -> Iterator[_T]: ...
hash: ClassVar[None] # type: ignore[assignment]
@overload
def getitem(self, i: SupportsIndex, /) -> _T: ...
@overload
def getitem(self, s: slice, /) -> list[_T]: ...
@overload
def setitem(self, key: SupportsIndex, value: _T, /) -> None: ...
@overload
def setitem(self, key: slice, value: Iterable[_T], /) -> None: ...
def delitem(self, key: SupportsIndex | slice, /) -> None: ...
# Overloading looks unnecessary, but is needed to work around complex mypy problems
@overload
def add(self, value: list[_T], /) -> list[_T]: ...
@overload
def add(self, value: list[_S], /) -> list[_S | _T]: ...
def iadd(self, value: Iterable[_T], /) -> Self: ... # type: ignore[misc]
def mul(self, value: SupportsIndex, /) -> list[_T]: ...
def rmul(self, value: SupportsIndex, /) -> list[_T]: ...
def imul(self, value: SupportsIndex, /) -> Self: ...
def contains(self, key: object, /) -> bool: ...
def reversed(self) -> Iterator[_T]: ...
def gt(self, value: list[_T], /) -> bool: ...
def ge(self, value: list[_T], /) -> bool: ...
def lt(self, value: list[_T], /) -> bool: ...
def le(self, value: list[_T], /) -> bool: ...
def eq(self, value: object, /) -> bool: ...
def class_getitem(cls, item: Any, /) -> GenericAlias: ...

class dict(MutableMapping[_KT, _VT]):
# init should be kept roughly in line with collections.UserDict.__init__, which has similar semantics
# Also multiprocessing.managers.SyncManager.dict()
@overload
def init(self) -> None: ...
@overload
def init(self: dict[str, _VT], **kwargs: _VT) -> None: ... # pyright: ignore[reportInvalidTypeVarUse] #11780
@overload
def init(self, map: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...
@overload
def init(
self: dict[str, _VT], # pyright: ignore[reportInvalidTypeVarUse] #11780
map: SupportsKeysAndGetItem[str, _VT],
/,
**kwargs: _VT,
) -> None: ...
@overload
def init(self, iterable: Iterable[tuple[_KT, _VT]], /) -> None: ...
@overload
def init(
self: dict[str, _VT], # pyright: ignore[reportInvalidTypeVarUse] #11780
iterable: Iterable[tuple[str, _VT]],
/,
**kwargs: _VT,
) -> None: ...
# Next two overloads are for dict(string.split(sep) for string in iterable)
# Cannot be Iterable[Sequence[_T]] or otherwise dict(["foo", "bar", "baz"]) is not an error
@overload
def init(self: dict[str, str], iterable: Iterable[list[str]], /) -> None: ...
@overload
def init(self: dict[bytes, bytes], iterable: Iterable[list[bytes]], /) -> None: ...
def new(cls, *args: Any, **kwargs: Any) -> Self: ...
def copy(self) -> dict[_KT, _VT]: ...
def keys(self) -> dict_keys[_KT, _VT]: ...
def values(self) -> dict_values[_KT, _VT]: ...
def items(self) -> dict_items[_KT, _VT]: ...
# Signature of dict.fromkeys should be kept identical to
# fromkeys methods of OrderedDict/ChainMap/UserDict in collections
# TODO: the true signature of dict.fromkeys is not expressible in the current type system.
# See #3800 & https://github.com/python/typing/issues/548#issuecomment-683336963.
@classmethod
@overload
def fromkeys(cls, iterable: Iterable[_T], value: None = None, /) -> dict[_T, Any | None]: ...
@classmethod
@overload
def fromkeys(cls, iterable: Iterable[_T], value: _S, /) -> dict[_T, _S]: ...
# Positional-only in dict, but not in MutableMapping
@overload # type: ignore[override]
def get(self, key: _KT, default: None = None, /) -> _VT | None: ...
@overload
def get(self, key: _KT, default: _VT, /) -> _VT: ...
@overload
def get(self, key: _KT, default: _T, /) -> _VT | _T: ...
@overload
def pop(self, key: _KT, /) -> _VT: ...
@overload
def pop(self, key: _KT, default: _VT, /) -> _VT: ...
@overload
def pop(self, key: _KT, default: _T, /) -> _VT | _T: ...
def len(self) -> int: ...
def getitem(self, key: _KT, /) -> _VT: ...
def setitem(self, key: _KT, value: _VT, /) -> None: ...
def delitem(self, key: _KT, /) -> None: ...
def iter(self) -> Iterator[_KT]: ...
def eq(self, value: object, /) -> bool: ...
def reversed(self) -> Iterator[_KT]: ...
hash: ClassVar[None] # type: ignore[assignment]
def class_getitem(cls, item: Any, /) -> GenericAlias: ...
@overload
def or(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...
@overload
def or(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...
@overload
def ror(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...
@overload
def ror(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...
# dict.ior should be kept roughly in line with MutableMapping.update()
@overload # type: ignore[misc]
def ior(self, value: SupportsKeysAndGetItem[_KT, _VT], /) -> Self: ...
@overload
def ior(self, value: Iterable[tuple[_KT, _VT]], /) -> Self: ...

class set(MutableSet[_T]):
@overload
def init(self) -> None: ...
@overload
def init(self, iterable: Iterable[_T], /) -> None: ...
def add(self, element: _T, /) -> None: ...
def copy(self) -> set[_T]: ...
def difference(self, *s: Iterable[Any]) -> set[_T]: ...
def difference_update(self, *s: Iterable[Any]) -> None: ...
def discard(self, element: _T, /) -> None: ...
def intersection(self, *s: Iterable[Any]) -> set[_T]: ...
def intersection_update(self, *s: Iterable[Any]) -> None: ...
def isdisjoint(self, s: Iterable[Any], /) -> bool: ...
def issubset(self, s: Iterable[Any], /) -> bool: ...
def issuperset(self, s: Iterable[Any], /) -> bool: ...
def remove(self, element: _T, /) -> None: ...
def symmetric_difference(self, s: Iterable[_T], /) -> set[_T]: ...
def symmetric_difference_update(self, s: Iterable[_T], /) -> None: ...
def union(self, *s: Iterable[_S]) -> set[_T | _S]: ...
def update(self, *s: Iterable[_T]) -> None: ...
def len(self) -> int: ...
def contains(self, o: object, /) -> bool: ...
def iter(self) -> Iterator[_T]: ...
def and(self, value: AbstractSet[object], /) -> set[_T]: ...
def iand(self, value: AbstractSet[object], /) -> Self: ...
def or(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...
def ior(self, value: AbstractSet[_T], /) -> Self: ... # type: ignore[override,misc]
def sub(self, value: AbstractSet[_T | None], /) -> set[_T]: ...
def isub(self, value: AbstractSet[object], /) -> Self: ...
def xor(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...
def ixor(self, value: AbstractSet[_T], /) -> Self: ... # type: ignore[override,misc]
def le(self, value: AbstractSet[object], /) -> bool: ...
def lt(self, value: AbstractSet[object], /) -> bool: ...
def ge(self, value: AbstractSet[object], /) -> bool: ...
def gt(self, value: AbstractSet[object], /) -> bool: ...
def eq(self, value: object, /) -> bool: ...
hash: ClassVar[None] # type: ignore[assignment]
def class_getitem(cls, item: Any, /) -> GenericAlias: ...

class frozenset(AbstractSet[_T_co]):
@overload
def new(cls) -> Self: ...
@overload
def new(cls, iterable: Iterable[_T_co], /) -> Self: ...
def copy(self) -> frozenset[_T_co]: ...
def difference(self, *s: Iterable[object]) -> frozenset[_T_co]: ...
def intersection(self, *s: Iterable[object]) -> frozenset[_T_co]: ...
def isdisjoint(self, s: Iterable[_T_co], /) -> bool: ...
def issubset(self, s: Iterable[object], /) -> bool: ...
def issuperset(self, s: Iterable[object], /) -> bool: ...
def symmetric_difference(self, s: Iterable[_T_co], /) -> frozenset[_T_co]: ...
def union(self, *s: Iterable[_S]) -> frozenset[_T_co | _S]: ...
def len(self) -> int: ...
def contains(self, o: object, /) -> bool: ...
def iter(self) -> Iterator[_T_co]: ...
def and(self, value: AbstractSet[_T_co], /) -> frozenset[_T_co]: ...
def or(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...
def sub(self, value: AbstractSet[_T_co], /) -> frozenset[_T_co]: ...
def xor(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...
def le(self, value: AbstractSet[object], /) -> bool: ...
def lt(self, value: AbstractSet[object], /) -> bool: ...
def ge(self, value: AbstractSet[object], /) -> bool: ...
def gt(self, value: AbstractSet[object], /) -> bool: ...
def eq(self, value: object, /) -> bool: ...
def hash(self) -> int: ...
def class_getitem(cls, item: Any, /) -> GenericAlias: ...

class enumerate(Generic[_T]):
def new(cls, iterable: Iterable[_T], start: int = 0) -> Self: ...
def iter(self) -> Self: ...
def next(self) -> tuple[int, _T]: ...
def class_getitem(cls, item: Any, /) -> GenericAlias: ...

@final
class range(Sequence[int]):
@property
def start(self) -> int: ...
@property
def stop(self) -> int: ...
@property
def step(self) -> int: ...
@overload
def new(cls, stop: SupportsIndex, /) -> Self: ...
@overload
def new(cls, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ..., /) -> Self: ...
def count(self, value: int, /) -> int: ...
def index(self, value: int, /) -> int: ... # type: ignore[override]
def len(self) -> int: ...
def eq(self, value: object, /) -> bool: ...
def hash(self) -> int: ...
def contains(self, key: object, /) -> bool: ...
def iter(self) -> Iterator[int]: ...
@overload
def getitem(self, key: SupportsIndex, /) -> int: ...
@overload
def getitem(self, key: slice, /) -> range: ...
def reversed(self) -> Iterator[int]: ...

class property:
fget: Callable[[Any], Any] | None
fset: Callable[[Any, Any], None] | None
fdel: Callable[[Any], None] | None
isabstractmethod: bool
if sys.version_info >= (3, 13):
name: str

def __init__(
    self,
    fget: Callable[[Any], Any] | None = ...,
    fset: Callable[[Any, Any], None] | None = ...,
    fdel: Callable[[Any], None] | None = ...,
    doc: str | None = ...,
) -> None: ...
def getter(self, fget: Callable[[Any], Any], /) -> property: ...
def setter(self, fset: Callable[[Any, Any], None], /) -> property: ...
def deleter(self, fdel: Callable[[Any], None], /) -> property: ...
@overload
def __get__(self, instance: None, owner: type, /) -> Self: ...
@overload
def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
def __set__(self, instance: Any, value: Any, /) -> None: ...
def __delete__(self, instance: Any, /) -> None: ...

@final
class _NotImplementedType(Any):
call: None

NotImplemented: _NotImplementedType

def abs(x: SupportsAbs[_T], /) -> _T: ...
def all(iterable: Iterable[object], /) -> bool: ...
def any(iterable: Iterable[object], /) -> bool: ...
def ascii(obj: object, /) -> str: ...
def bin(number: int | SupportsIndex, /) -> str: ...
def breakpoint(*args: Any, **kws: Any) -> None: ...
def callable(obj: object, /) -> TypeIs[Callable[..., object]]: ...
def chr(i: int | SupportsIndex, /) -> str: ...

We define this here instead of using os.PathLike to avoid import cycle issues.
See https://github.com/python/typeshed/pull/991#issuecomment-288160993
class _PathLike(Protocol[AnyStr_co]):
def fspath(self) -> AnyStr_co: ...

if sys.version_info >= (3, 10):
def aiter(async_iterable: SupportsAiter[_SupportsAnextT_co], /) -> _SupportsAnextT_co: ...

class _SupportsSynchronousAnext(Protocol[_AwaitableT_co]):
    def __anext__(self) -> _AwaitableT_co: ...

@overload
# `anext` is not, in fact, an async function. When default is not provided
# `anext` is just a passthrough for `obj.__anext__`
# See discussion in #7491 and pure-Python implementation of `anext` at https://github.com/python/cpython/blob/ea786a882b9ed4261eafabad6011bc7ef3b5bf94/Lib/test/test_asyncgen.py#L52-L80
def anext(i: _SupportsSynchronousAnext[_AwaitableT], /) -> _AwaitableT: ...
@overload
async def anext(i: SupportsAnext[_T], default: _VT, /) -> _T | _VT: ...

compile() returns a CodeType, unless the flags argument includes PyCF_ONLY_AST (=1024),
in which case it returns ast.AST. We have overloads for flag 0 (the default) and for
explicitly passing PyCF_ONLY_AST. We fall back to Any for other values of flags.
@overload
def compile(
source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,
filename: str | ReadableBuffer | _PathLike[Any],
mode: str,
flags: Literal[0],
dont_inherit: bool = False,
optimize: int = -1,
*,
_feature_version: int = -1,
) -> CodeType: ...
@overload
def compile(
source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,
filename: str | ReadableBuffer | _PathLike[Any],
mode: str,
*,
dont_inherit: bool = False,
optimize: int = -1,
_feature_version: int = -1,
) -> CodeType: ...
@overload
def compile(
source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,
filename: str | ReadableBuffer | _PathLike[Any],
mode: str,
flags: Literal[1024],
dont_inherit: bool = False,
optimize: int = -1,
*,
_feature_version: int = -1,
) -> _ast.AST: ...
@overload
def compile(
source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,
filename: str | ReadableBuffer | _PathLike[Any],
mode: str,
flags: int,
dont_inherit: bool = False,
optimize: int = -1,
*,
_feature_version: int = -1,
) -> Any: ...

copyright: _sitebuiltins._Printer
credits: _sitebuiltins._Printer

def delattr(obj: object, name: str, /) -> None: ...
def dir(o: object = ..., /) -> list[str]: ...
@overload
def divmod(x: SupportsDivMod[_T_contra, _T_co], y: _T_contra, /) -> _T_co: ...
@overload
def divmod(x: _T_contra, y: SupportsRDivMod[_T_contra, _T_co], /) -> _T_co: ...

The globals argument to eval has to be dict[str, Any] rather than dict[str, object] due to invariance.
(The globals argument has to be a “real dict”, rather than any old mapping, unlike the locals argument.)
if sys.version_info >= (3, 13):
def eval(
source: str | ReadableBuffer | CodeType,
/,
globals: dict[str, Any] | None = None,
locals: Mapping[str, object] | None = None,
) -> Any: ...

else:
def eval(
source: str | ReadableBuffer | CodeType,
globals: dict[str, Any] | None = None,
locals: Mapping[str, object] | None = None,
/,
) -> Any: ...

Comment above regarding eval applies to exec as well
if sys.version_info >= (3, 13):
def exec(
source: str | ReadableBuffer | CodeType,
/,
globals: dict[str, Any] | None = None,
locals: Mapping[str, object] | None = None,
*,
closure: tuple[CellType, ...] | None = None,
) -> None: ...

elif sys.version_info >= (3, 11):
def exec(
source: str | ReadableBuffer | CodeType,
globals: dict[str, Any] | None = None,
locals: Mapping[str, object] | None = None,
/,
*,
closure: tuple[CellType, ...] | None = None,
) -> None: ...

else:
def exec(
source: str | ReadableBuffer | CodeType,
globals: dict[str, Any] | None = None,
locals: Mapping[str, object] | None = None,
/,
) -> None: ...

exit: _sitebuiltins.Quitter

class filter(Generic[_T]):
@overload
def new(cls, function: None, iterable: Iterable[_T | None], /) -> Self: ...
@overload
def new(cls, function: Callable[[_S], TypeGuard[_T]], iterable: Iterable[_S], /) -> Self: ...
@overload
def new(cls, function: Callable[[_S], TypeIs[_T]], iterable: Iterable[_S], /) -> Self: ...
@overload
def new(cls, function: Callable[[_T], Any], iterable: Iterable[_T], /) -> Self: ...
def iter(self) -> Self: ...
def next(self) -> _T: ...

def format(value: object, format_spec: str = "", /) -> str: ...
@overload
def getattr(o: object, name: str, /) -> Any: ...

While technically covered by the last overload, spelling out the types for None, bool
and basic containers help mypy out in some tricky situations involving type context
(aka bidirectional inference)
@overload
def getattr(o: object, name: str, default: None, /) -> Any | None: ...
@overload
def getattr(o: object, name: str, default: bool, /) -> Any | bool: ...
@overload
def getattr(o: object, name: str, default: list[Any], /) -> Any | list[Any]: ...
@overload
def getattr(o: object, name: str, default: dict[Any, Any], /) -> Any | dict[Any, Any]: ...
@overload
def getattr(o: object, name: str, default: _T, /) -> Any | _T: ...
def globals() -> dict[str, Any]: ...
def hasattr(obj: object, name: str, /) -> bool: ...
def hash(obj: object, /) -> int: ...

help: _sitebuiltins._Helper

def hex(number: int | SupportsIndex, /) -> str: ...
def id(obj: object, /) -> int: ...
def input(prompt: object = "", /) -> str: ...

class _GetItemIterable(Protocol[_T_co]):
def getitem(self, i: int, /) -> _T_co: ...

@overload
def iter(object: SupportsIter[_SupportsNextT_co], /) -> _SupportsNextT_co: ...
@overload
def iter(object: _GetItemIterable[_T], /) -> Iterator[_T]: ...
@overload
def iter(object: Callable[[], _T | None], sentinel: None, /) -> Iterator[_T]: ...
@overload
def iter(object: Callable[[], _T], sentinel: object, /) -> Iterator[_T]: ...

Keep this alias in sync with unittest.case._ClassInfo
if sys.version_info >= (3, 10):
_ClassInfo: TypeAlias = type | types.UnionType | tuple[_ClassInfo, ...]
else:
_ClassInfo: TypeAlias = type | tuple[_ClassInfo, ...]

def isinstance(obj: object, class_or_tuple: _ClassInfo, /) -> bool: ...
def issubclass(cls: type, class_or_tuple: _ClassInfo, /) -> bool: ...
def len(obj: Sized, /) -> int: ...

license: _sitebuiltins._Printer

def locals() -> dict[str, Any]: ...

class map(Generic[_S]):
# 3.14 adds strict argument.
if sys.version_info >= (3, 14):
@overload
def new(cls, func: Callable[[_T1], _S], iterable: Iterable[_T1], /, *, strict: bool = False) -> Self: ...
@overload
def new(
cls, func: Callable[[_T1, _T2], _S], iterable: Iterable[_T1], iter2: Iterable[_T2], /, *, strict: bool = False
) -> Self: ...
@overload
def new(
cls,
func: Callable[[_T1, _T2, _T3], _S],
iterable: Iterable[_T1],
iter2: Iterable[_T2],
iter3: Iterable[_T3],
/,
*,
strict: bool = False,
) -> Self: ...
@overload
def new(
cls,
func: Callable[[_T1, _T2, _T3, _T4], _S],
iterable: Iterable[_T1],
iter2: Iterable[_T2],
iter3: Iterable[_T3],
iter4: Iterable[_T4],
/,
*,
strict: bool = False,
) -> Self: ...
@overload
def new(
cls,
func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],
iterable: Iterable[_T1],
iter2: Iterable[_T2],
iter3: Iterable[_T3],
iter4: Iterable[_T4],
iter5: Iterable[_T5],
/,
*,
strict: bool = False,
) -> Self: ...
@overload
def new(
cls,
func: Callable[..., _S],
iterable: Iterable[Any],
iter2: Iterable[Any],
iter3: Iterable[Any],
iter4: Iterable[Any],
iter5: Iterable[Any],
iter6: Iterable[Any],
/,
*iterables: Iterable[Any],
strict: bool = False,
) -> Self: ...
else:
@overload
def new(cls, func: Callable[[_T1], _S], iterable: Iterable[_T1], /) -> Self: ...
@overload
def new(cls, func: Callable[[_T1, _T2], _S], iterable: Iterable[_T1], iter2: Iterable[_T2], /) -> Self: ...
@overload
def new(
cls, func: Callable[[_T1, _T2, _T3], _S], iterable: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /
) -> Self: ...
@overload
def new(
cls,
func: Callable[[_T1, _T2, _T3, _T4], _S],
iterable: Iterable[_T1],
iter2: Iterable[_T2],
iter3: Iterable[_T3],
iter4: Iterable[_T4],
/,
) -> Self: ...
@overload
def new(
cls,
func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],
iterable: Iterable[_T1],
iter2: Iterable[_T2],
iter3: Iterable[_T3],
iter4: Iterable[_T4],
iter5: Iterable[_T5],
/,
) -> Self: ...
@overload
def new(
cls,
func: Callable[..., _S],
iterable: Iterable[Any],
iter2: Iterable[Any],
iter3: Iterable[Any],
iter4: Iterable[Any],
iter5: Iterable[Any],
iter6: Iterable[Any],
/,
*iterables: Iterable[Any],
) -> Self: ...

def __iter__(self) -> Self: ...
def __next__(self) -> _S: ...

@overload
def max(
arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None
) -> SupportsRichComparisonT: ...
@overload
def max(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
@overload
def max(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...
@overload
def max(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
@overload
def max(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
@overload
def max(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
@overload
def min(
arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None
) -> SupportsRichComparisonT: ...
@overload
def min(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
@overload
def min(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...
@overload
def min(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
@overload
def min(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
@overload
def min(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
@overload
def next(i: SupportsNext[_T], /) -> _T: ...
@overload
def next(i: SupportsNext[_T], default: _VT, /) -> _T | _VT: ...
def oct(number: int | SupportsIndex, /) -> str: ...

_Opener: TypeAlias = Callable[[str, int], int]

Text mode: always returns a TextIOWrapper
@overload
def open(
file: FileDescriptorOrPath,
mode: OpenTextMode = "r",
buffering: int = -1,
encoding: str | None = None,
errors: str | None = None,
newline: str | None = None,
closefd: bool = True,
opener: _Opener | None = None,
) -> TextIOWrapper: ...

Unbuffered binary mode: returns a FileIO
@overload
def open(
file: FileDescriptorOrPath,
mode: OpenBinaryMode,
buffering: Literal[0],
encoding: None = None,
errors: None = None,
newline: None = None,
closefd: bool = True,
opener: _Opener | None = None,
) -> FileIO: ...

Buffering is on: return BufferedRandom, BufferedReader, or BufferedWriter
@overload
def open(
file: FileDescriptorOrPath,
mode: OpenBinaryModeUpdating,
buffering: Literal[-1, 1] = -1,
encoding: None = None,
errors: None = None,
newline: None = None,
closefd: bool = True,
opener: _Opener | None = None,
) -> BufferedRandom: ...
@overload
def open(
file: FileDescriptorOrPath,
mode: OpenBinaryModeWriting,
buffering: Literal[-1, 1] = -1,
encoding: None = None,
errors: None = None,
newline: None = None,
closefd: bool = True,
opener: _Opener | None = None,
) -> BufferedWriter: ...
@overload
def open(
file: FileDescriptorOrPath,
mode: OpenBinaryModeReading,
buffering: Literal[-1, 1] = -1,
encoding: None = None,
errors: None = None,
newline: None = None,
closefd: bool = True,
opener: _Opener | None = None,
) -> BufferedReader: ...

Buffering cannot be determined: fall back to BinaryIO
@overload
def open(
file: FileDescriptorOrPath,
mode: OpenBinaryMode,
buffering: int = -1,
encoding: None = None,
errors: None = None,
newline: None = None,
closefd: bool = True,
opener: _Opener | None = None,
) -> BinaryIO: ...

Fallback if mode is not specified
@overload
def open(
file: FileDescriptorOrPath,
mode: str,
buffering: int = -1,
encoding: str | None = None,
errors: str | None = None,
newline: str | None = None,
closefd: bool = True,
opener: _Opener | None = None,
) -> IO[Any]: ...
def ord(c: str | bytes | bytearray, /) -> int: ...

class _SupportsWriteAndFlush(SupportsWrite[_T_contra], SupportsFlush, Protocol[_T_contra]): ...

@overload
def print(
*values: object,
sep: str | None = " ",
end: str | None = "\n",
file: SupportsWrite[str] | None = None,
flush: Literal[False] = False,
) -> None: ...
@overload
def print(
*values: object, sep: str | None = " ", end: str | None = "\n", file: _SupportsWriteAndFlush[str] | None = None, flush: bool
) -> None: ...

_E_contra = TypeVar("_E_contra", contravariant=True)
_M_contra = TypeVar("_M_contra", contravariant=True)

class _SupportsPow2(Protocol[_E_contra, _T_co]):
def pow(self, other: _E_contra, /) -> _T_co: ...

class _SupportsPow3NoneOnly(Protocol[_E_contra, _T_co]):
def pow(self, other: _E_contra, modulo: None = None, /) -> _T_co: ...

class _SupportsPow3(Protocol[_E_contra, _M_contra, _T_co]):
def pow(self, other: _E_contra, modulo: _M_contra, /) -> _T_co: ...

_SupportsSomeKindOfPow = ( # noqa: Y026 # TODO: Use TypeAlias once mypy bugs are fixed
_SupportsPow2[Any, Any] | _SupportsPow3NoneOnly[Any, Any] | _SupportsPow3[Any, Any, Any]
)

TODO: pow(int, int, Literal[0]) fails at runtime,
but adding a NoReturn overload isn't a good solution for expressing that (see #8566).
@overload
def pow(base: int, exp: int, mod: int) -> int: ...
@overload
def pow(base: int, exp: Literal[0], mod: None = None) -> Literal[1]: ...
@overload
def pow(base: int, exp: _PositiveInteger, mod: None = None) -> int: ...
@overload
def pow(base: int, exp: _NegativeInteger, mod: None = None) -> float: ...

int base & positive-int exp -> int; int base & negative-int exp -> float
return type must be Any as int | float causes too many false-positive errors
@overload
def pow(base: int, exp: int, mod: None = None) -> Any: ...
@overload
def pow(base: _PositiveInteger, exp: float, mod: None = None) -> float: ...
@overload
def pow(base: _NegativeInteger, exp: float, mod: None = None) -> complex: ...
@overload
def pow(base: float, exp: int, mod: None = None) -> float: ...

float base & float exp could return float or complex
return type must be Any (same as complex base, complex exp),
as float | complex causes too many false-positive errors
@overload
def pow(base: float, exp: complex | _SupportsSomeKindOfPow, mod: None = None) -> Any: ...
@overload
def pow(base: complex, exp: complex | _SupportsSomeKindOfPow, mod: None = None) -> complex: ...
@overload
def pow(base: _SupportsPow2[_E_contra, _T_co], exp: _E_contra, mod: None = None) -> _T_co: ... # type: ignore[overload-overlap]
@overload
def pow(base: _SupportsPow3NoneOnly[_E_contra, _T_co], exp: _E_contra, mod: None = None) -> _T_co: ... # type: ignore[overload-overlap]
@overload
def pow(base: _SupportsPow3[_E_contra, _M_contra, _T_co], exp: _E_contra, mod: _M_contra) -> _T_co: ...
@overload
def pow(base: _SupportsSomeKindOfPow, exp: float, mod: None = None) -> Any: ...
@overload
def pow(base: _SupportsSomeKindOfPow, exp: complex, mod: None = None) -> complex: ...

quit: _sitebuiltins.Quitter

class reversed(Generic[_T]):
@overload
def new(cls, sequence: Reversible[_T], /) -> Iterator[_T]: ... # type: ignore[misc]
@overload
def new(cls, sequence: SupportsLenAndGetItem[_T], /) -> Iterator[_T]: ... # type: ignore[misc]
def iter(self) -> Self: ...
def next(self) -> _T: ...
def length_hint(self) -> int: ...

def repr(obj: object, /) -> str: ...

See https://github.com/python/typeshed/pull/9141
and https://github.com/python/typeshed/pull/9151
on why we don't use SupportsRound from typing.pyi
class _SupportsRound1(Protocol[_T_co]):
def round(self) -> _T_co: ...

class _SupportsRound2(Protocol[_T_co]):
def round(self, ndigits: int, /) -> _T_co: ...

@overload
def round(number: _SupportsRound1[_T], ndigits: None = None) -> _T: ...
@overload
def round(number: _SupportsRound2[_T], ndigits: SupportsIndex) -> _T: ...

See https://github.com/python/typeshed/pull/6292#discussion_r748875189
for why arg 3 of setattr should be annotated with Any and not object
def setattr(obj: object, name: str, value: Any, /) -> None: ...
@overload
def sorted(
iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, reverse: bool = False
) -> list[SupportsRichComparisonT]: ...
@overload
def sorted(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> list[_T]: ...

_AddableT1 = TypeVar("_AddableT1", bound=SupportsAdd[Any, Any])
_AddableT2 = TypeVar("_AddableT2", bound=SupportsAdd[Any, Any])

class _SupportsSumWithNoDefaultGiven(SupportsAdd[Any, Any], SupportsRAdd[int, Any], Protocol): ...

_SupportsSumNoDefaultT = TypeVar("_SupportsSumNoDefaultT", bound=_SupportsSumWithNoDefaultGiven)

In general, the return type of x + x is not guaranteed to be the same type as x.
However, we can't express that in the stub for sum()
without creating many false-positive errors (see #7578).
Instead, we special-case the most common examples of this: bool and literal integers.
@overload
def sum(iterable: Iterable[bool | _LiteralInteger], /, start: int = 0) -> int: ...
@overload
def sum(iterable: Iterable[_SupportsSumNoDefaultT], /) -> _SupportsSumNoDefaultT | Literal[0]: ...
@overload
def sum(iterable: Iterable[_AddableT1], /, start: _AddableT2) -> _AddableT1 | _AddableT2: ...

The argument to vars() has to have a __dict__ attribute, so the second overload can't be annotated with object
(A “SupportsDunderDict” protocol doesn't work)
@overload
def vars(object: type, /) -> types.MappingProxyType[str, Any]: ...
@overload
def vars(object: Any = ..., /) -> dict[str, Any]: ...

class zip(Generic[_T_co]):
if sys.version_info >= (3, 10):
@overload
def new(cls, *, strict: bool = ...) -> zip[Any]: ...
@overload
def new(cls, iter1: Iterable[_T1], /, *, strict: bool = ...) -> zip[tuple[_T1]]: ...
@overload
def new(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /, *, strict: bool = ...) -> zip[tuple[_T1, _T2]]: ...
@overload
def new(
cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /, *, strict: bool = ...
) -> zip[tuple[_T1, _T2, _T3]]: ...
@overload
def new(
cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /, *, strict: bool = ...
) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...
@overload
def new(
cls,
iter1: Iterable[_T1],
iter2: Iterable[_T2],
iter3: Iterable[_T3],
iter4: Iterable[_T4],
iter5: Iterable[_T5],
/,
*,
strict: bool = ...,
) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
@overload
def new(
cls,
iter1: Iterable[Any],
iter2: Iterable[Any],
iter3: Iterable[Any],
iter4: Iterable[Any],
iter5: Iterable[Any],
iter6: Iterable[Any],
/,
*iterables: Iterable[Any],
strict: bool = ...,
) -> zip[tuple[Any, ...]]: ...
else:
@overload
def new(cls) -> zip[Any]: ...
@overload
def new(cls, iter1: Iterable[_T1], /) -> zip[tuple[_T1]]: ...
@overload
def new(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> zip[tuple[_T1, _T2]]: ...
@overload
def new(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /) -> zip[tuple[_T1, _T2, _T3]]: ...
@overload
def new(
cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /
) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...
@overload
def new(
cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], /
) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
@overload
def new(
cls,
iter1: Iterable[Any],
iter2: Iterable[Any],
iter3: Iterable[Any],
iter4: Iterable[Any],
iter5: Iterable[Any],
iter6: Iterable[Any],
/,
*iterables: Iterable[Any],
) -> zip[tuple[Any, ...]]: ...

def __iter__(self) -> Self: ...
def __next__(self) -> _T_co: ...

Signature of builtins.__import__ should be kept identical to importlib.__import__
Return type of __import__ should be kept the same as return type of importlib.import_module
def import(
name: str,
globals: Mapping[str, object] | None = None,
locals: Mapping[str, object] | None = None,
fromlist: Sequence[str] = (),
level: int = 0,
) -> types.ModuleType: ...
def build_class(func: Callable[[], CellType | Any], name: str, /, *bases: Any, metaclass: Any = ..., **kwds: Any) -> Any: ...

if sys.version_info >= (3, 10):
from types import EllipsisType

# Backwards compatibility hack for folks who relied on the ellipsis type
# existing in typeshed in Python 3.9 and earlier.
ellipsis = EllipsisType

Ellipsis: EllipsisType

else:
# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's
# not exposed anywhere under that name, we make it private here.
@final
@type_check_only
class ellipsis: ...

Ellipsis: ellipsis

class BaseException:
args: tuple[Any, ...]
cause: BaseException | None
context: BaseException | None
suppress_context: bool
traceback: TracebackType | None
def init(self, *args: object) -> None: ...
def new(cls, *args: Any, **kwds: Any) -> Self: ...
def setstate(self, state: dict[str, Any] | None, /) -> None: ...
def with_traceback(self, tb: TracebackType | None, /) -> Self: ...
if sys.version_info >= (3, 11):
# only present after add_note() is called
notes: list[str]
def add_note(self, note: str, /) -> None: ...

class GeneratorExit(BaseException): ...
class KeyboardInterrupt(BaseException): ...

class SystemExit(BaseException):
code: sys._ExitCode

class Exception(BaseException): ...

class StopIteration(Exception):
value: Any

class OSError(Exception):
errno: int | None
strerror: str | None
# filename, filename2 are actually str | bytes | None
filename: Any
filename2: Any
if sys.platform == "win32":
winerror: int

EnvironmentError = OSError
IOError = OSError
if sys.platform == "win32":
WindowsError = OSError

class ArithmeticError(Exception): ...
class AssertionError(Exception): ...

class AttributeError(Exception):
if sys.version_info >= (3, 10):
def init(self, *args: object, name: str | None = ..., obj: object = ...) -> None: ...
name: str
obj: object

class BufferError(Exception): ...
class EOFError(Exception): ...

class ImportError(Exception):
def init(self, *args: object, name: str | None = ..., path: str | None = ...) -> None: ...
name: str | None
path: str | None
msg: str # undocumented
if sys.version_info >= (3, 12):
name_from: str | None # undocumented

class LookupError(Exception): ...
class MemoryError(Exception): ...

class NameError(Exception):
if sys.version_info >= (3, 10):
def init(self, *args: object, name: str | None = ...) -> None: ...
name: str

class ReferenceError(Exception): ...
class RuntimeError(Exception): ...
class StopAsyncIteration(Exception): ...

class SyntaxError(Exception):
msg: str
filename: str | None
lineno: int | None
offset: int | None
text: str | None
# Errors are displayed differently if this attribute exists on the exception.
# The value is always None.
print_file_and_line: None
if sys.version_info >= (3, 10):
end_lineno: int | None
end_offset: int | None

@overload
def __init__(self) -> None: ...
@overload
def __init__(self, msg: object, /) -> None: ...
# Second argument is the tuple (filename, lineno, offset, text)
@overload
def __init__(self, msg: str, info: tuple[str | None, int | None, int | None, str | None], /) -> None: ...
if sys.version_info >= (3, 10):
    # end_lineno and end_offset must both be provided if one is.
    @overload
    def __init__(
        self, msg: str, info: tuple[str | None, int | None, int | None, str | None, int | None, int | None], /
    ) -> None: ...
# If you provide more than two arguments, it still creates the SyntaxError, but
# the arguments from the info tuple are not parsed. This form is omitted.

class SystemError(Exception): ...
class TypeError(Exception): ...
class ValueError(Exception): ...
class FloatingPointError(ArithmeticError): ...
class OverflowError(ArithmeticError): ...
class ZeroDivisionError(ArithmeticError): ...
class ModuleNotFoundError(ImportError): ...
class IndexError(LookupError): ...
class KeyError(LookupError): ...
class UnboundLocalError(NameError): ...

class BlockingIOError(OSError):
characters_written: int

class ChildProcessError(OSError): ...
class ConnectionError(OSError): ...
class BrokenPipeError(ConnectionError): ...
class ConnectionAbortedError(ConnectionError): ...
class ConnectionRefusedError(ConnectionError): ...
class ConnectionResetError(ConnectionError): ...
class FileExistsError(OSError): ...
class FileNotFoundError(OSError): ...
class InterruptedError(OSError): ...
class IsADirectoryError(OSError): ...
class NotADirectoryError(OSError): ...
class PermissionError(OSError): ...
class ProcessLookupError(OSError): ...
class TimeoutError(OSError): ...
class NotImplementedError(RuntimeError): ...
class RecursionError(RuntimeError): ...
class IndentationError(SyntaxError): ...
class TabError(IndentationError): ...
class UnicodeError(ValueError): ...

class UnicodeDecodeError(UnicodeError):
encoding: str
object: bytes
start: int
end: int
reason: str
def init(self, encoding: str, object: ReadableBuffer, start: int, end: int, reason: str, /) -> None: ...

class UnicodeEncodeError(UnicodeError):
encoding: str
object: str
start: int
end: int
reason: str
def init(self, encoding: str, object: str, start: int, end: int, reason: str, /) -> None: ...

class UnicodeTranslateError(UnicodeError):
encoding: None
object: str
start: int
end: int
reason: str
def init(self, object: str, start: int, end: int, reason: str, /) -> None: ...

class Warning(Exception): ...
class UserWarning(Warning): ...
class DeprecationWarning(Warning): ...
class SyntaxWarning(Warning): ...
class RuntimeWarning(Warning): ...
class FutureWarning(Warning): ...
class PendingDeprecationWarning(Warning): ...
class ImportWarning(Warning): ...
class UnicodeWarning(Warning): ...
class BytesWarning(Warning): ...
class ResourceWarning(Warning): ...

if sys.version_info >= (3, 10):
class EncodingWarning(Warning): ...

if sys.version_info >= (3, 11):
_BaseExceptionT_co = TypeVar("_BaseExceptionT_co", bound=BaseException, covariant=True, default=BaseException)
_BaseExceptionT = TypeVar("_BaseExceptionT", bound=BaseException)
_ExceptionT_co = TypeVar("_ExceptionT_co", bound=Exception, covariant=True, default=Exception)
_ExceptionT = TypeVar("_ExceptionT", bound=Exception)

# See `check_exception_group.py` for use-cases and comments.
class BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):
    def __new__(cls, message: str, exceptions: Sequence[_BaseExceptionT_co], /) -> Self: ...
    def __init__(self, message: str, exceptions: Sequence[_BaseExceptionT_co], /) -> None: ...
    @property
    def message(self) -> str: ...
    @property
    def exceptions(self) -> tuple[_BaseExceptionT_co | BaseExceptionGroup[_BaseExceptionT_co], ...]: ...
    @overload
    def subgroup(
        self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
    ) -> ExceptionGroup[_ExceptionT] | None: ...
    @overload
    def subgroup(
        self, condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...], /
    ) -> BaseExceptionGroup[_BaseExceptionT] | None: ...
    @overload
    def subgroup(
        self, condition: Callable[[_BaseExceptionT_co | Self], bool], /
    ) -> BaseExceptionGroup[_BaseExceptionT_co] | None: ...
    @overload
    def split(
        self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
    ) -> tuple[ExceptionGroup[_ExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
    @overload
    def split(
        self, condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...], /
    ) -> tuple[BaseExceptionGroup[_BaseExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
    @overload
    def split(
        self, condition: Callable[[_BaseExceptionT_co | Self], bool], /
    ) -> tuple[BaseExceptionGroup[_BaseExceptionT_co] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
    # In reality it is `NonEmptySequence`:
    @overload
    def derive(self, excs: Sequence[_ExceptionT], /) -> ExceptionGroup[_ExceptionT]: ...
    @overload
    def derive(self, excs: Sequence[_BaseExceptionT], /) -> BaseExceptionGroup[_BaseExceptionT]: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...

class ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):
    def __new__(cls, message: str, exceptions: Sequence[_ExceptionT_co], /) -> Self: ...
    def __init__(self, message: str, exceptions: Sequence[_ExceptionT_co], /) -> None: ...
    @property
    def exceptions(self) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]: ...
    # We accept a narrower type, but that's OK.
    @overload  # type: ignore[override]
    def subgroup(
        self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
    ) -> ExceptionGroup[_ExceptionT] | None: ...
    @overload
    def subgroup(self, condition: Callable[[_ExceptionT_co | Self], bool], /) -> ExceptionGroup[_ExceptionT_co] | None: ...
    @overload  # type: ignore[override]
    def split(
        self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
    ) -> tuple[ExceptionGroup[_ExceptionT] | None, ExceptionGroup[_ExceptionT_co] | None]: ...
    @overload
    def split(
        self, condition: Callable[[_ExceptionT_co | Self], bool], /
    ) -> tuple[ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None]: ...

if sys.version_info >= (3, 13):
class PythonFinalizationError(RuntimeError): ...

what is this? Is this the code behind pygame?

Boots
Ah, young coder, you’ve stumbled onto a vast crypt of code, but this is not the code behind pygame! What you’ve pasted is a portion of Python’s built-in type stubs, sometimes from builtins.pyi or similar files. These files describe the types and methods for Python's built-in objects (like str, list, and int) to help tools like type-checkers, editors, and IDEs provide better autocomplete and error detection.

It is not the implementation of pygame, nor even of Python per se—it is a type declaration for developers and static analysis tools.

If you’re exploring pygame, you’ll want to look for actual .py files containing pygame’s logic, or for the pygame documentation.
This file is not responsible for your game’s error.
You probably reached this file because of an error or stack trace during debugging; Python sometimes refers to these files in advanced error scenarios.
If you’d like to see how pygame works “under the hood,” you can:

Look at the pygame GitHub repository
Read the documentation, or
Use the help() function in your Python shell
Would you like help finding the part of your code that’s causing your original AttributeError, or are you just curious about these stubs?


Shaunythunder
how do I do something once and then don't call it again. break?

Boots
Excellent question! If you want to do something only once inside a loop and then stop the loop after that action, yes, you can use break. The break statement immediately exits the innermost loop, so anything after it in the loop body doesn't run for subsequent iterations.

Here’s a simple example:

for item in [1, 2, 3, 4, 5]:
    print("Doing this once!")
    break  # After this, the loop ends and doesn't repeat

In this example, "Doing this once!" will only print a single time, even though the loop is over a list of 5 items.

You might also want to control what you do once outside of a loop, or based on a condition. In such cases, you could use a flag variable (like done = False) to ensure your action only happens the first time a certain condition is met.

Would you like to see an example of using a flag, or does this answer your question?


Thumbs up
Thumbs down
Logic Assistance
Chat ID: 98
Greeting Message
Asteroi
Lesson Complete
Code Progression
Lesson Update
UFO Implementation
Collision Debug
Chat ID: 90
Chat ID: 40
Overlay Transparency
Overlay Manager
Lives Display
Force Push
Score Update
Chat ID: 2C
Git Sync
Spacing Issue
High Score
Name Input
Score System
Course Completion
Course Finished
Course Complete
Course Done
Environment Initialization

Ask Boots a question...










