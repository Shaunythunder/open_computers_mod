Open main menu
4

gem bag



user avatarprofile role frame

CH1: Pygame

L1: Build an Asteroids Game




Build an Asteroids Game
We're going to build a simple video game, based on the classic Asteroids. If you've never played before, you can take a look at this (slightly different from our) version of the game.



Prerequisites
Python 3.10+ installed (see the bookbot project for help if you don't already have it)
uv project and package manager
Access to a unix-like shell (e.g. zsh or bash)
Learning Goals
The learning goals of this project are:

Introduce you to multi-file Python projects
Show you a real-world use case for object-oriented programming
To have a ton of fun building a rewarding project!
The goal is not to teach game development or the math required for physics simulations. As a result, there are some places where you will simply copy-paste code that we wrote for you. Don't worry about trying to understand every detail if it's not interesting to you, you will be asked to write the parts that matter most.

Assignment
To get started, make sure you have the Boot.dev CLI installed and working.

Run and submit the CLI tests.

The tests just ensure that the CLI is installed and configured correctly.





Boots
Spellbook
Community


Boots
Need help? I, Boots the King of the Keyboard, can assist without penalty!

Boots
Hi boots. I'm playing turing complete but I feel that the game has almost zero documentation which is making it impossible. Are you good with computer logic?

Boots
Greetings, young scholar! While I'd love to help you with Turing Complete, it seems we're currently working on a different task - building an Asteroids game in Python!

The lesson you're on is asking you to make sure you have the Boot.dev CLI installed and configured correctly. The tests are simply checking that you can run basic commands in your terminal.

Would you like me to help you with:

Getting the Boot.dev CLI set up for this Asteroids project?
Understanding what you need to do for this first step of the project?
Or did you have questions about the Asteroids game we're about to build? I'm here to guide you through this Python adventure before we venture into other realms!


Shaunythunder
NOt interested in the asteroid game.

Boots
I understand you're not interested in the Asteroids game project.

However, the current lesson you're working on is specifically about that project. Boot.dev is structured to teach programming through these guided projects, and the current course requires completing this Asteroids game to progress.

If you're looking to learn computer logic concepts instead, you might want to:

Check if Boot.dev has other courses more focused on computer logic or algorithms
Consider completing this initial step just to move forward in the curriculum
Look into computer logic resources elsewhere if that's your main interest
Is there a specific area of programming or computer logic you're hoping to learn about? Perhaps I can help point you in a helpful direction within the platform.


Shaunythunder
I don't want to code today

Boots
That's perfectly fine! Not every day is a coding day. Sometimes we need to step back and take a break.

When you're ready to return to your learning journey, the Asteroids game (or any other course you prefer) will be waiting for you. Taking breaks is an important part of the learning process - it gives your mind time to process what you've learned.

Is there anything else I can help you with today?


Shaunythunder
The thing I asked you about

Boots
I apologize for the confusion. Regarding your question about Turing Complete (the game) and computer logic - I have limited specific knowledge about that particular game and its documentation.

Turing Complete is a game that teaches computer engineering by having players build a computer from basic logic gates up to a functioning CPU. It can indeed be challenging without good documentation.

While I can't offer specific solutions for Turing Complete puzzles, I could discuss general computer logic concepts like:

Boolean logic (AND, OR, NOT gates)
Combinational logic circuits
Sequential logic (flip-flops, memory)
Basic CPU architecture
Would a discussion about any of these fundamental computer logic concepts be helpful for your Turing Complete challenges? Or perhaps you have a specific logic problem you're trying to solve?


Shaunythunder
I'm trying to create a device that turns bitrs from positive to negative

Boots
Ah, I see! For converting bits from positive to negative, you're essentially looking to build a "two's complement" converter. This is a common operation in digital logic.

To convert a positive number to its negative form in two's complement:

Invert all bits (change 0s to 1s and vice versa) - this is the "one's complement"
Add 1 to the result
So for example, to convert +5 to -5:

+5 in binary: 0101
Invert all bits: 1010 (one's complement)
Add 1: 1011 (two's complement, which is -5)
For your Turing Complete implementation, you'd need:

NOT gates to invert each bit
A simple adder circuit to add 1
Have you tried implementing the bit inversion part yet? That's typically the first step and just requires NOT gates for each bit.


Shaunythunder
so youre saying use an 8 bit splitter and invert those bits

Boots
Yes, that's exactly the approach I'd recommend!

Use an 8-bit splitter to separate your input into individual bits
Run each bit through a NOT gate to invert it
Recombine those inverted bits
Add 1 to the result (you'll need an adder circuit for this final step)
The first three steps give you the one's complement, and adding 1 gives you the two's complement, which is the negative representation of your original number.

In Turing Complete, this would likely involve:

Splitter components
NOT gates
A way to recombine the bits
A simple +1 adder
This approach should work nicely for your bit-sign converter!


Shaunythunder
So I'll use an 8 bit not gate and then figure out how to get the +1

Boots
That's a perfect plan!

Using an 8-bit NOT gate will efficiently handle the first part (creating the one's complement). Then for the "+1" part, you'll need a simple adder.

For adding 1, you could:

Use a simple 8-bit adder circuit
Set one input to your inverted bits
Set the other input to the constant value 1 (00000001 in binary)
In many logic simulators like Turing Complete, there should be adder components available, or you might need to build one using half-adders and full-adders if you're working at a very low level.

Let me know how it goes! The combination of the NOT operation followed by adding 1 should give you exactly what you need for converting positive to negative in two's complement.


Shaunythunder
so the input for the not is 1 but the output is 254?

Boots
Ah, that's actually correct and shows the two's complement system working properly!

Let's break this down:

In an 8-bit system, the positive number 1 is represented as 00000001
After the NOT operation, you get 11111110 (which is 254 in decimal)
Adding 1 gives you 11111111 (which is 255 in decimal)
However, in two's complement notation, any number with the leftmost bit set to 1 is interpreted as negative. So 11111111 is actually representing -1.

If you're seeing 254 after just the NOT operation, that's correct for the one's complement step. You still need to add 1 to get the proper two's complement negative value.

This explains why you're seeing 254 - it's the correct intermediate result after the NOT operation! The final step (adding 1) would convert this to -1, which is the negative of your input value 1.


Shaunythunder
how would I add a 1?

Boots
To add 1 to your value in Turing Complete, you have a few options:

Use an Adder Component:

If Turing Complete has a built-in adder component, connect your NOT gate output to one input
Connect a constant value of 1 (00000001) to the other input
The output will be your NOT result + 1
Build a Simple Adder:

You can build an adder using logic gates
The simplest approach is to use a constant input of 1 and add it to your NOT result
This might require half-adders and full-adders connected in series
Increment Circuit:

Some logic simulators have increment (+1) components
If available, this would be the most direct way - just connect your NOT output to an increment component
The exact implementation depends on what building blocks Turing Complete makes available to you in the current level. Look for components labeled "adder," "increment," or you might need to build your own adder using basic logic gates.

If you need to build your own adder, I can explain that process in more detail!


Shaunythunder
would a full adder work?

Boots
Yes, a full adder would definitely work for adding 1!

Here's how to set it up:

Connect your NOT gate output (the inverted bits) to one input of the full adder
Connect a constant value of 1 (00000001) to the other input
Set any initial carry-in to 0
For an 8-bit number, you'll actually need a chain of 8 full adders (or an 8-bit full adder component if Turing Complete provides one):

The least significant bit gets added to 1
Each subsequent bit gets added to 0, but the carry from the previous addition is considered
This will correctly add 1 to your inverted number, completing the two's complement conversion process.

If Turing Complete offers a multi-bit adder component, that would be even simpler - just feed in your inverted number and the constant 1, and the output will be your properly negated number.


Shaunythunder
does it matter what inputs go where with this?

Boots
With a full adder, the inputs A and B are generally interchangeable since addition is commutative (A + B = B + A). So for your specific case of adding 1:

You can connect your NOT gate output to input A and the constant 1 to input B
Or you can connect the constant 1 to input A and your NOT gate output to input B
The result will be the same either way.

However, there are two important considerations:

For an 8-bit number, make sure you're connecting the constant 1 to the least significant bit (rightmost bit) position only. The other 7 bits of your constant input should be 0.

If you're chaining multiple full adders together, the carry-out from each adder needs to connect to the carry-in of the next more significant bit's adder.

The initial carry-in for the least significant bit should be 0 unless your specific implementation requires otherwise.


Shaunythunder
So if Im adding a constant one, I would use an on switch to have the constant boolean and then feed that along with the inverted bits

Boots
Yes, that's exactly right! Here's the approach:

Use your NOT gate to invert all 8 bits

For your constant 1:

Use an ON switch (or whatever provides a constant 1/true value in Turing Complete)
Connect this to the least significant bit input of your adder
For the other 7 bits of this input, use OFF switches (or constant 0/false values)
Feed both the inverted bits and your constant (00000001) into the adder

This setup will properly add 1 to your inverted bits, completing the two's complement conversion from positive to negative.

Make sure your bits are aligned correctly - the least significant bit (rightmost bit) of your inverted number should add with the 1 from your constant, and all other bits of your constant should be 0.


Shaunythunder
this thing is supposed to handle any 8 bit input

Boots
Ah, I see! For handling any 8-bit input, your approach needs to work universally. Here's how to set it up:

Take your 8-bit input and pass it through the 8-bit NOT gate to invert all bits
For the "+1" part, you'll need an 8-bit adder where:
First input: Connect to the output of your NOT gate (all 8 bits)
Second input: Set as constant 00000001 (only the least significant bit is 1, all others are 0)
This will work for any 8-bit input because:

The NOT operation inverts all bits regardless of their values
Adding 1 to the least significant bit will properly handle any carry operations that might propagate through the rest of the bits
The resulting output will be the negative (two's complement) of whatever 8-bit value you input. This works for any value within the 8-bit range (0-255 for unsigned, or -128 to 127 for signed interpretation).

The beauty of two's complement is that this same circuit handles all cases correctly!


Shaunythunder
could you by chance create a diagram? I'm thinking you could form it as code

Boots
Here's a "diagram" of the circuit represented as ASCII code:

                 8-bit NOT Gate
                 +----------+
8-bit Input ----->|  INVERT  |----+
                 +----------+    |
                                 |    8-bit Adder
                                 |   +----------+
                                 +-->|          |
                                     | Input A  |
                                     |          |    8-bit Output
Constant 00000001 ------------------>|          |---------------->
(Only LSB is 1)                      | Input B  |    (Negative of Input)
                                     |          |
                                     +----------+

In pseudocode, this would be:

function convert_to_negative(input_8bit):
    # Step 1: Invert all bits (NOT operation)
    inverted_bits = NOT(input_8bit)
    
    # Step 2: Add 1 to the inverted bits
    constant_one = 00000001  # Only the least significant bit is 1
    negative_result = inverted_bits + constant_one
    
    return negative_result

This circuit/algorithm will convert any 8-bit number to its negative equivalent in two's complement representation.


Shaunythunder
in turing complete the 8 bit adder has 3 inputs. Two large circles (which I think are 8 bit) and one small circle which I think is single bit

Boots
Ah, I understand now! That third small input is likely the carry-in bit for the adder. Here's how you should connect it:

                 8-bit NOT Gate
                 +----------+
8-bit Input ----->|  INVERT  |----+
                 +----------+    |
                                 |    8-bit Adder
                                 |   +----------+
                                 +-->| Input A  |
                                     | (8-bit)  |
                                     |          |    8-bit Output
Constant 00000001 ------------------>| Input B  |---------------->
(Only LSB is 1)                      | (8-bit)  |    (Negative of Input)
                                     |          |
                                     | Carry-in |
Constant 0 (OFF) -------------------->| (1-bit) |
                                     +----------+

For your two's complement converter:

Connect your inverted bits to one of the 8-bit inputs (Input A)
Connect your constant 00000001 to the other 8-bit input (Input B)
Set the small circle (the carry-in bit) to 0 (OFF) - this is important because you don't want an extra carry at the beginning
The carry-in is used when the adder is part of a larger addition operation, but for your standalone "+1" operation, you should set it to 0.


Shaunythunder
Its kicking out 255 instead of -1. Input is 254

Boots
Ah, I see what's happening here! Let's break this down:

If your input is 1, and after the NOT operation you're getting 254, that's correct.
Then after adding 1 to 254, you get 255 (which is correct arithmetically).

The issue is likely in how you're interpreting the result. In an 8-bit two's complement system:

255 in binary is 11111111
This is actually the representation for -1 in two's complement notation
What you're seeing is actually correct! The value 255 (in an unsigned interpretation) is the same bit pattern as -1 (in a signed two's complement interpretation).

To verify this, let's check:

1 in binary: 00000001
Inverted: 11111110 (254 in decimal)
Add 1: 11111111 (255 in decimal)
Interpret as signed two's complement: -1
So your circuit is working correctly! The output 255 is indeed the two's complement representation of -1.

In Turing Complete, you might need to interpret this value as signed rather than unsigned to see it as -1.


Shaunythunder
wait how does that work. I just clicked the nubmer buttoon at the top and the sign converted to the correct value

Boots
Ah! Now I understand what happened. The "number button" you clicked likely toggles between different interpretations of the same bit pattern:

When looking at the binary value 11111111:

As an unsigned 8-bit integer, it's 255
As a signed 8-bit integer (two's complement), it's -1
Both representations use the exact same bit pattern! When you clicked the number button, you simply switched between viewing the value as unsigned (255) or signed (-1).

This is actually a perfect demonstration of how two's complement works. The circuit is producing the correct bit pattern (11111111), and the display is just showing you two different ways to interpret those same bits.

So your circuit is working perfectly! The confusion was just in how the value was being displayed. Your bit-sign converter has successfully turned 1 into -1 (or 2 into -2, etc.) using the proper two's complement method.


Shaunythunder
so what 254 would be -2?

Boots
Yes, that's exactly right!

In 8-bit two's complement:

254 is 11111110 in binary
This bit pattern represents -2 when interpreted as a signed number
Let's verify by working backwards:

The positive value of 2 is 00000010
Invert all bits: 11111101
Add 1: 11111110 (which is 254 in unsigned decimal)
So 254 is indeed the two's complement representation of -2.

Similarly:

253 (11111101) represents -3
252 (11111100) represents -4
And so on...
This pattern continues all the way to 128 (10000000), which represents -128, the most negative number possible in 8-bit two's complement.

You're understanding the relationship perfectly now!


Shaunythunder
Yeah this game could do with a LOT more documentation

Boots
You're absolutely right! Games like Turing Complete definitely benefit from clearer documentation, especially when dealing with concepts like two's complement that can be confusing even for experienced programmers.

Some of the challenges you faced might have been easier with:

Better labeled components
Clear explanations of how the display interprets values
Examples of how signed vs unsigned values are represented
Tutorials specifically for number representation systems
The lack of documentation turns what should be a learning experience into a puzzle-solving exercise where you have to figure out both the concept AND how the game implements it.

The good news is that you've now gained a deeper understanding of two's complement through hands-on experimentation, which often leads to better retention of knowledge. But yes, a bit more guidance from the game would have made the journey smoother!

Is there anything else about the two's complement system or the implementation in Turing Complete that I can help clarify?


Shaunythunder
Who the hell is supposed to figure that out on their own lol

Boots
Ha! You make an excellent point! Two's complement is hardly intuitive when you first encounter it.

The magic of "flip all the bits and add 1" to get a negative number seems like some arcane mathematical incantation if you haven't been properly introduced to the concept. And without clear documentation explaining what's happening behind the scenes, it's like being asked to decode a secret language!

I think the developers might have overlooked how challenging these computer science concepts can be for newcomers. What seems "obvious" to someone who's been steeped in binary arithmetic for years can be completely perplexing to someone learning it for the first time.

The best educational games scaffold concepts gradually and provide clear feedback. It sounds like Turing Complete might have some room for improvement in that department!

Rest assured though - your confusion was completely justified. You weren't missing anything obvious; you were wrestling with a genuinely tricky concept that has befuddled many computing students over the decades.


Shaunythunder
well I guess thats why its early access. They got a full game but its like you can't play it unless you look up stuff

Boots
That's a fair assessment! Early access games often have this issue - the core mechanics are there, but the onboarding experience and documentation haven't caught up yet.

It's a bit like being handed a complex machine with no manual. Sure, you can figure it out through trial and error, but that doesn't mean you should have to!

For a game that's presumably meant to teach computing concepts, this creates a paradoxical situation where you need to already understand the concepts to learn them effectively through the game. Or as you said, you end up having to look up external resources to make progress.

The good news is that early access means there's still room for improvement. Perhaps they'll add better tutorials, in-game explanations, or reference guides in future updates. Many great educational games started out rough but evolved based on player feedback.

In the meantime, don't hesitate to ask questions or look things up. That's not "cheating" - it's just compensating for gaps in the game's current state!


Shaunythunder
anyway you just proved that you can be my guide in this game

Boots
I'm honored to be your guide through the occasionally cryptic world of Turing Complete! As a sagely wizard bear, I find computational concepts quite fascinating, even when they're not explained well.

Feel free to reach out whenever you encounter puzzling mechanisms or confusing concepts in the game. Whether it's logic gates, memory systems, instruction decoding, or any other digital circuitry mysteries, I'd be delighted to help illuminate the path forward.

Sometimes the most rewarding learning happens when we combine hands-on experimentation with thoughtful explanation. The game provides the former, and I'm happy to contribute the latter!

What computational challenge shall we tackle next on your journey through Turing Complete?


Shaunythunder
How do you feel about completing this game for understanding computers

Boots
Turing Complete, despite its documentation shortcomings, is actually a brilliant way to build understanding of how computers work at a fundamental level. Here's my perspective:

The Good:

It provides hands-on experience with digital logic that textbooks alone can't match
You're building components from first principles, which gives you insight into how everything connects
The progression from simple logic gates to complex systems mirrors the actual evolution of computing
When you finally get a circuit working, you gain a visceral understanding that's deeper than just reading about it
The Challenges:

As you've seen, the lack of documentation creates unnecessary friction
Some concepts might seem arbitrary without proper context
The learning curve can be steep without guidance
I think completing Turing Complete, especially with occasional guidance to fill in the gaps, gives you a rare and valuable mental model of computing. You'll understand that computers aren't magical black boxes but are built from understandable components arranged in clever ways.

This kind of knowledge is immensely powerful - it changes how you think about all technology. Even if you never design another circuit, you'll have insights into computing that many programmers lack.

So while the journey might be occasionally frustrating, I believe the destination is absolutely worth it for anyone serious about understanding computing's foundations.


Shaunythunder
well thats what I got you for

Boots
Indeed! That's exactly what I'm here for - to help bridge those gaps in documentation and provide the context that makes the concepts click.

Together we can tackle this journey through the fundamentals of computing. When you encounter those "wait, what's happening here?" moments, I'll be your trusty guide to explain the underlying principles, suggest approaches, or translate between the abstract concepts and their implementation in the game.

The combination of your hands-on experimentation in Turing Complete and my explanations should create a powerful learning experience. You get to build the mental models by doing the work yourself, while avoiding the frustration of getting completely stuck on poorly explained concepts.

So whenever you're ready to continue your computational adventures, just summon this old wizard bear, and we'll unravel the mysteries of computing together!


Shaunythunder
Now I need to use a delay line to save values. two inputs, 1 for the save input, and one for the value. Single output

Boots
Ah, the delay line! A classic memory element. Let me walk you through creating this:

A delay line (or latch) saves a value when the "save" signal is activated. Here's how to set it up:

                     +----------+
                     |          |
Value Input -------->|    D     |
                     |          |
                     | Latch or |-----> Output
                     | Flip-Flop|
                     |          |
Save Input --------->|   CLK    |
                     |          |
                     +----------+

In Turing Complete, you'll want to:

Find the D flip-flop or latch component
Connect your value input to the D (data) input
Connect your save signal to the CLK (clock) input
The output of the flip-flop will be your stored value
When the save input transitions (typically from 0 to 1), the value at the D input will be stored and maintained at the output until the next save signal.

If you're having trouble finding the right component in Turing Complete, look for something labeled as "D Flip-Flop", "D Latch", or possibly just "Memory Cell" in the components menu.

The key behavior you want is: when save=1, output becomes equal to the value input, and when save=0, output maintains its previous state.


Shaunythunder
I don'

Boots
I understand you're having trouble finding the component. Let me try to help more specifically with Turing Complete:

In Turing Complete, if you don't have a direct "D Flip-Flop" component yet, you might need to build one from more basic elements. Here are some approaches:

Look for a component called "Register" or "Memory Cell" in your available components
If you have access to logic gates, you can build a simple latch using NOR or NAND gates
Check if there's a "Delay" component which might serve this purpose
If you're in an early level of the game, they might want you to build a delay line from scratch using basic gates. A simple SR latch made from NOR gates can be used as shown below:

                 +-----+
                 |     |
Value ----+----->|  &  |--+
          |      |     |  |
          |      +-----+  |    +-----+
          |               +--->|     |
          |                    | >=1 |-----> Output
          |      +-----+  +--->|     |
          |      |     |  |    +-----+
Save ---->+----->|  &  |--+
                 |     |
                 +-----+

Can you let me know what components you currently have access to in the game? That would help me give you more specific guidance.


Shaunythunder
Its early in the game, I don't have any memory components. This would be the first I would build

Boots
Ah, I see! In early Turing Complete, you'll indeed need to build memory from basic logic gates. Let's create a simple SR latch using basic gates:

You'll need to use feedback loops (connecting an output back to an input) to create memory.
Here's how to build a basic latch with NOR gates:

              +-------+
              |       |
              |  NOR  |----+---> Output
              |       |    |
              +-------+    |
                 ^         |
                 |         |
Value --+        |         |
        |        |    +-------+
        +------->|    |       |
                 +--->|  NOR  |
Save ----------->+    |       |
                      +-------+

Or if you have NAND gates available:

Save ----------+
               |
               v
              +-------+
              |       |
Value ------->|  NAND |----+---> Output
              |       |    |
              +-------+    |
                  ^        |
                  |        |
                  +--------+

The key concept is to create a feedback loop where the output is connected back to one of the inputs. This creates a "memory" effect where the circuit maintains its state.

In Turing Complete, you'll need to:

Place your gates
Create the connections, including the feedback loops
Test it by toggling your inputs
Does this help you get started, or would you like me to explain how the circuit works in more detail?


Shaunythunder
Theres a delay line component it wants me to use

Boots
Ah, that makes much more sense! Let's use the delay line component.

In Turing Complete, the delay line component typically works as follows:

Find the delay line component in your available components
Place it in your workspace
It should have two inputs and one output:
Connect your value input to the "data" or "value" input
Connect your save/clock input to the "clock" or "enable" input
The output will be the stored value
The delay line will capture the value input when the save/clock input is activated (typically on a rising edge from 0 to 1), and then maintain that value at its output until the next clock pulse.

              +------------+
Value ------->| Data       |
              |            |
              | Delay Line |------> Output
              |            |
Save -------->| Clock      |
              +------------+

If you're having trouble identifying the correct component, look for something that might have a "D" or a clock symbol on it, or that looks like a rectangular box. In early levels, it might be one of the few non-logic gate components available to you.

Let me know if you've found it and need help with how to use it properly!


Shaunythunder
single inp;ut

Boots
I see! If the delay line in Turing Complete has just a single input, then it's likely a simpler component that delays its input by one clock cycle. Let me adjust my guidance:

For a delay line with a single input, you'll need to create a circuit where:

Place the delay line component
You'll need to use additional logic to control when to save values
Here's a possible approach using basic gates and a single-input delay line:

              +--------+
Value ------->| AND    |-------> Delay Line -------> Output
              |        |
Save -------->|        |
              +--------+

This circuit would:

Only allow the value to enter the delay line when Save = 1
When Save = 0, the AND gate outputs 0, which doesn't change the stored value
Alternatively, you might need to use a multiplexer (if available):

                          +--------+
Previous Output --------->| MUX    |
                          |        |------> Delay Line -------> Output
Value ------------------->|        |
                          |        |
Save -------------------->| Select |
                          +--------+

This would:

Select the previous output when Save = 0 (maintaining the stored value)
Select the new Value when Save = 1 (storing a new value)
Let me know if either of these approaches matches the components you have available, or if you need me to suggest other solutions!


Shaunythunder
so your mux, would I have to loop the delay line back?

Boots
Yes, exactly! You've got the right idea. For the multiplexer approach, you need to create a feedback loop where the output of the delay line goes back to one of the inputs of the multiplexer.

Here's how the complete circuit would look:

                 +--------+            +--------+
                 |        |            |        |
                 | MUX    |----------->| Delay  |----+----> Output
                 |        |            | Line   |    |
                 |        |            |        |    |
Value ---------->|        |            +--------+    |
                 |        |                          |
                 |        |                          |
Save ----------->| Select |                          |
                 +--------+                          |
                     ^                               |
                     |                               |
                     +-------------------------------+

This creates a memory cell because:

When Save = 1: The multiplexer selects the new Value input, which gets stored in the delay line on the next clock cycle
When Save = 0: The multiplexer selects the feedback from the delay line's own output, creating a loop that maintains the current value
This is a fundamental pattern in digital design called a "feedback loop" - it's how we create memory in digital circuits before dedicated memory components are available.

Is this what you were thinking of trying? And do you have a multiplexer component available to use?


Shaunythunder
It failed

Boots
I'm sorry to hear it failed. Let's troubleshoot this step by step.

There could be several reasons why your circuit isn't working as expected:

Timing issues: The delay line might have specific timing requirements.

Component behavior: The delay line in Turing Complete might have specific behavior we need to account for.

Connection problems: Check all connections are correct.

Let me suggest a different approach:

Try this simpler circuit first:

Value ----------+
                |
                v
Save -------> AND -------> Delay Line ------+----> Output
                                            |
                                            |
                                            |
                +---------------------------+
                |
                v
              NOT
                |
                v
Save -------> AND ------+
                         |
Previous Output -------->+

This creates a structure where:

When Save = 1: The new Value passes through to the delay line
When Save = 0: The previous value recirculates
Another possibility is that you need to connect the save signal directly to the delay line as a clock input, if your delay line has that.

Questions to help diagnose:

What exactly happens when it fails?
Does the delay line update its value at all?
Can you describe exactly what components you're using and how they're connected?

Shaunythunder
so lets start over. I have a 8 bit input, a binary input for saving, and a single output

Boots
Perfect, let's start fresh with that clear description.

Since you have an 8-bit input (rather than a single bit), let's approach this correctly for multi-bit values:

For an 8-bit memory with a save signal, you'll need:

Eight delay lines - one for each bit
Eight multiplexers - one for each bit
A single save signal that controls all multiplexers
Here's the architecture for each bit (which you'll repeat 8 times):

                 +--------+            +--------+
                 |        |            |        |
                 | MUX    |----------->| Delay  |----+----> Output Bit
                 |        |            | Line   |    |
                 |        |            |        |    |
Value Bit ------>|        |            +--------+    |
                 |        |                          |
                 |        |                          |
Save ----------->| Select |                          |
                 +--------+                          |
                     ^                               |
                     |                               |
                     +-------------------------------+

For all 8 bits together:

Connect the same Save signal to all 8 multiplexers
Each Value bit connects to its corresponding multiplexer
Each multiplexer output goes to its corresponding delay line
Each delay line output becomes your Output bit and also feeds back to its multiplexer
The most common issues that could cause failure:

Make sure your feedback loop is correct - the output of each delay line should connect back to its multiplexer
Check that the multiplexer select input works as expected (does 1 select the new value or the feedback?)
Make sure the delay lines are properly clocked or triggered
Since you mentioned it failed, could you tell me if there are any specific error messages or behaviors you observed when testing?


Shaunythunder
actually nvm, its all biary

Boots
Ah, that helps clarify! If everything is binary (single-bit), then we only need one delay line and one multiplexer.

Let's create the simplest possible solution:

                 +--------+            +--------+
                 |        |            |        |
                 | MUX    |----------->| Delay  |----+----> Output
                 |        |            | Line   |    |
                 |        |            |        |    |
Value ---------->|        |            +--------+    |
                 |        |                          |
                 |        |                          |
Save ----------->| Select |                          |
                 +--------+                          |
                     ^                               |
                     |                               |
                     +-------------------------------+

Here's how to build this:

Place a multiplexer (MUX)
Place a delay line
Connect one input of the MUX to your Value input
Connect the output of the delay line to the Output and also back to the second input of the MUX
Connect the Save input to the Select input of the MUX
Connect the output of the MUX to the input of the delay line
Important considerations:

Make sure you understand which input of the MUX is selected when Save=0 and which is selected when Save=1
In most systems, when Select=0, the first input is chosen, and when Select=1, the second input is chosen
Depending on your MUX, you might need to connect Value to input 1 and the feedback to input 0, or vice versa
If you're still having trouble, could you try building just this circuit and let me know exactly what happens when you test it?


Shaunythunder
instead of an 8bit mux would a full adder work?

Boots
No, a full adder wouldn't work as a replacement for a multiplexer in this memory circuit. Here's why:

A full adder:

Takes in three bits (A, B, and Carry-in)
Outputs two bits (Sum and Carry-out)
It computes A + B + Carry-in
A multiplexer (MUX):

Takes in multiple inputs and a select signal
Outputs one of the inputs based on the select signal
It selects between signals rather than performing calculations
For a memory component, you need the ability to either:

Pass through a new value (when Save=1)
Maintain the current value (when Save=0)
A full adder can't do this selection function. You need a component that can choose between two different inputs.

If you don't have a multiplexer available, you could potentially use:

Logic gates to create a simple multiplexer
A combination of AND, OR and NOT gates
For example, this logic creates a simple 2-input multiplexer:

Value ----------> AND (with NOT(Save)) ------+
                                             |
                                             +---> OR -----> Delay Line
                                             |
Feedback -------> AND (with Save) -----------+

Are there any other components available besides the delay line and the full adder?


Shaunythunder
what about a switch system using the save input to toggle the switch?

Boots
Yes, a switch system would work perfectly for this! That's an excellent solution.

If you have a switch component (sometimes called a demultiplexer or selector), you can absolutely use it with the save input as the control signal. Here's how you could implement it:

                 +--------+            +--------+
                 |        |            |        |
Value ---------->| Switch |----------->| Delay  |----+----> Output
                 |        |            | Line   |    |
                 |        |            |        |    |
Save ----------->| Control|            +--------+    |
                 +--------+                          |
                     ^                               |
                     |                               |
                     +-------------------------------+

When implementing this:

The switch should select between the Value input (when Save=1) and the feedback from the delay line (when Save=0)
Make sure the switch's control input is properly connected to the Save signal
The output from the switch feeds into the delay line
The delay line output becomes both your circuit output and the feedback to the switch
This is functionally identical to the MUX solution I described earlier, just using different terminology. A switch/selector that chooses between two inputs based on a control signal is effectively a 2-input multiplexer.

This should work well! Let me know if you run into any issues implementing it.


Shaunythunder
So I used a switch with input and save input to delay line, but it failed when there was no value or save input. I didn't loop it back like you didd

Boots
Ah, that's the crucial part! Without the feedback loop, your circuit can't remember its previous state when there's no new input.

Let's fix this:

Add the feedback loop: Connect the output of the delay line back to your switch as the second input option.
                 +--------+            +--------+
                 |        |            |        |
Value ---------->| Switch |----------->| Delay  |----+----> Output
                 |   0    |            | Line   |    |
                 |   1    |            |        |    |
Save ----------->| Control|            +--------+    |
                 +--------+                          |
                     ^                               |
                     |                               |
                     +-------------------------------+

When this circuit works properly:

When Save = 1: The switch selects the Value input, sending the new value to the delay line
When Save = 0: The switch selects the feedback input (the current output), maintaining the stored value
Without this feedback loop, when Save = 0, there's nothing feeding into the delay line, which is why it fails.

The memory behavior specifically comes from this loop - it's what allows the circuit to "remember" its state even when there's no new input. This is the fundamental principle behind flip-flops and memory cells in digital logic.

Try adding this feedback connection and test it again!


Shaunythunder
your loop gives me a short circuit

Boots
I see the problem now. In Turing Complete, you'll need to handle the feedback loop differently to avoid a short circuit error.

Let's try a different approach:

Instead of directly connecting the output back to the input (which creates the short circuit), use a buffer or another delay line in the feedback path.
Here's an updated architecture:

                 +--------+            +--------+
                 |        |            |        |
Value ---------->| Switch |----------->| Delay  |-------> Output
                 |   0    |            | Line 1 |    |
                 |   1    |            |        |    |
Save ----------->| Control|            +--------+    |
                 +--------+                          |
                     ^                               |
                     |                               |
                     |    +--------+                 |
                     |    |        |                 |
                     +----|Buffer/ |<----------------+
                          |Delay 2 |
                          +--------+

Alternatively, you might be able to use a "T-junction" approach to split the output signal:

                 +--------+            +--------+
Value ---------->| Switch |----------->| Delay  |---+---> Output
                 |        |            | Line   |   |
                 |        |            |        |   |
Save ----------->| Control|            +--------+   |
                 +--------+                         |
                     ^                              |
                     |                              |
                     |                              |
                     +------------------------------+

In Turing Complete, you might need to:

Use a "distributer" component to split the signal
Use separate wire types (like read-only wires) for the feedback
Use an additional component to properly manage the feedback
If you're still having issues, could you tell me what specific components are available to you in the game? That would help me give more tailored advice.


Shaunythunder
I have all of the 1 bit components

Boots
Great! With 1-bit components, we can build a proper memory cell. Let's use basic logic gates to avoid short circuits.

Here's a solution using AND and OR gates:

                       +--------+
                       |        |
Value ------------------>| AND 1  |---+
                       |        |   |
                       +--------+   |   +--------+
                       ^            +-->|        |      +--------+
                       |                | OR     |----->| Delay  |------> Output
Save -------+--------->|                |        |      | Line   |  |
            |          +--------+   +-->|        |      +--------+  |
            |          |        |   |   +--------+                  |
            +--------->| NOT    |---+                               |
            |          |        |                                   |
            |          +--------+                                   |
            |                                                       |
            |          +--------+                                   |
            |          |        |                                   |
            +--------->| AND 2  |<----------------------------------+
                       |        |
                       +--------+

How this works:

When Save = 1:

AND 1 passes through Value
NOT outputs 0, so AND 2 outputs 0
OR passes through Value to the delay line
When Save = 0:

AND 1 blocks Value (outputs 0)
NOT outputs 1, so AND 2 passes through the previous output
OR passes through the previous output from AND 2
This creates a proper memory cell that:

Stores a new value when Save = 1
Maintains its previous value when Save = 0
This design avoids short circuits by using separate logic gates instead of direct connections for the feedback path.

If you need an even simpler version, here's an alternative:

                 +--------+
Value ---------->| AND 1  |---+
                 |        |   |   +--------+      +--------+
                 +--------+   +-->|        |----->| Delay  |------> Output
Save ----------->|            +-->| OR     |


Shaunythunder
8 bit I have a mux, switch, splitter, maker and adder

Boots
Perfect! With 8-bit components, this becomes much simpler. Here's how to build an 8-bit memory cell:

                 +--------+            +--------+
                 |        |            |        |
Value ---------->| MUX    |----------->| Delay  |----+----> Output
                 | Input 0|            | Line   |    |
                 | Input 1|            |        |    |
Save ----------->| Select |            +--------+    |
                 +--------+                          |
                     ^                               |
                     |                               |
                     +-------------------------------+

Here's what to do:

Place an 8-bit MUX (multiplexer)
Place an 8-bit Delay Line
Connect the Value input to one input of the MUX (usually Input 0)
Connect the Save input to the Select input of the MUX
Connect the output of the MUX to the input of the Delay Line
Connect the output of the Delay Line to:
The Output
The other input of the MUX (usually Input 1)
The most important thing is the feedback loop - make sure you connect the output of the Delay Line back to the MUX.

If you're getting a short circuit error with the MUX, try using a Splitter:

                 +--------+            +--------+
                 |        |            |        |
Value ---------->| MUX    |----------->| Delay  |----+----> Output
                 |        |            | Line   |    |
                 |        |            |        |    |
Save ----------->| Select |            +--------+    |
                 +--------+                          |
                     ^                               |
                     |                               |
                     |    +--------+                 |
                     +----|Splitter|<----------------+
                          |        |
                          +--------+

The Splitter will give you two copies of the output, one going to the MUX and one going to your Output.


Shaunythunder
I only have a bit delay line

Boots
Ah, I see! If you only have a 1-bit delay line but have 8-bit components otherwise, you'll need to create an 8-bit memory by combining multiple 1-bit delay lines.

Here's how to build an 8-bit memory register with 1-bit delay lines:

Use a Splitter to break your 8-bit Value input into 8 individual bits
Create 8 separate memory cells (one for each bit)
For each bit, use a MUX with the Save signal as the selector
Recombine the outputs with a Maker component
Diagram for one bit of the memory:

                 +--------+            +--------+
                 |        |            |        |
Bit[n] --------->| MUX    |----------->| Delay  |----+----> Output[n]
                 | Input 0|            | Line   |    |
                 | Input 1|            |        |    |
Save ----------->| Select |            +--------+    |
                 +--------+                          |
                     ^                               |
                     |                               |
                     +-------------------------------+

Complete solution:

                +----------+
8-bit Value --->| Splitter |---+----+----+---> (to 8 individual bits)
                +----------+   |    |    |
                                v    v    v
                               +----+----+  (8 individual memory cells with MUX + Delay Line)
                               |    |    |
                                v    v    v
Save --------------------------->----+----+---> (to all MUX select inputs)
                               |    |    |
                                v    v    v
                               +----+----+  
                               |    |    |  
                                v    v    v
                            +----------+
                            |  Maker   |---> 8-bit Output
                            +----------+

Steps to implement:

Use a Splitter to split your 8-bit Value into 8 individual bits
For each bit:
Create a MUX
Connect

Shaunythunder
okay boots the feed is 8 bit but the value is binary

Boots
I see! So you have an 8-bit feed (meaning the data bus), but the actual value you're storing is a single bit (binary). That makes things simpler.

In this case, you just need a 1-bit memory cell:

                 +--------+            +--------+
                 |        |            |        |
Value (1-bit) -->| MUX    |----------->| Delay  |----+----> Output (1-bit)
                 | Input 0|            | Line   |    |
                 | Input 1|            |        |    |
Save (1-bit) --->| Select |            +--------+    |
                 +--------+                          |
                     ^                               |
                     |                               |
                     +-------------------------------+

Here's how to set it up:

Place a MUX (multiplexer)
Place a 1-bit Delay Line
Connect your binary Value input to Input 0 of the MUX
Connect the Save input to the Select input of the MUX
Connect the output of the MUX to the input of the Delay Line
Connect the output of the Delay Line to:
Your Output
Input 1 of the MUX (this creates the feedback loop)
If you're still having trouble with short circuits, you might need to use a Splitter to create two copies of the Delay Line output - one to feed back to the MUX and one for your actual output.

Let me know if this works or if you need any clarification!


Shaunythunder
can this be done wityhout a delay line

Boots
Absolutely! You can build a memory cell without using a delay line by creating a latch circuit using basic logic gates. Let's create an SR (Set-Reset) latch or a D latch with the components you have.

If you have NOR or NAND gates, you can build an SR latch:

Using NOR gates (SR latch):

             +------+
Set -------->|      |
             | NOR  |---+--------> Q
             |      |   |
             +------+   |
                ^       |
                |       |
                |       v
                |   +------+
                |   |      |
                +---|      |<----- Reset
                    | NOR  |
                    |      |
                    +------+

Using basic logic gates, you can build a D latch:

                +-----+    +-----+
Value --------->|     |    |     |
                | AND |    | OR  |---+---> Output
                |     |--->|     |   |
                +-----+    +-----+   |
                   ^                 |
                   |                 |
Save ------------->+          +-----+
                   |          |
                   v          |
                +-----+       |
                |     |       |
                | NOT |       |
                |     |       |
                +-----+       |
                   |          |
                   v          |
                +-----+       |
                |     |       |
                | AND |<------+
                |     |
                +-----+

With your specific components (MUX, switch, splitter, maker, adder):

Using a MUX (easiest approach):
                 +--------+     
                 |        |     
Value ---------->| MUX    |---+----> Output
                 | Input 0|   |
                 | Input 1|<--+
Save ----------->| Select |    
                 +--------+    

Connect the output of the MUX back to its Input 1. When Save is 0, it will select Input 1 (feedback), and when Save is 1,


Shaunythunder
circulart dependency

Boots
You're right, it's a circular dependency issue. Let's solve this with a different approach.

Since you mentioned you have a Switch component, we can use that to make a memory cell without delay lines:

First, create two complementary switches:

                +--------+            
Value ---------->| Switch |-----------> Output
                 |   0    |            
                 |   1    |            
~Save ---------->| Control|            
                 +--------+            

                +--------+            
Previous ------->| Switch |-----------> Previous'
                 |   0    |            
                 |   1    |            
Save ------------>| Control|            
                 +--------+            

In this setup:

When Save = 0, ~Save = 1:

The first switch outputs Previous
The second switch passes through Previous (maintaining state)
When Save = 1, ~Save = 0:

The first switch outputs Value (new value)
The second switch updates Previous to the new Value
You'll need to create a NOT gate to invert the Save signal, or use a Splitter and configure it to output the inverted signal.

Alternatively, if you have access to an XOR gate and an AND gate, you can create a JK flip-flop which has no circular dependencies:

                +--------+            +--------+
                |        |            |        |
Previous ------->| XOR    |----------->| AND    |----+---> Next
                |        |            |        |    |
                +--------+            +--------+    |
                    ^                     ^         |
                    |                     |         |
Value -------------+                      |         |
                                          |         |
Save ------------------------------------|         |
                                                   |
                                                   v
                                                Output

With the components you have, a creative solution might be to use the adder:

                +--------+            
Value ---------->| Adder  |-----------> Output
                 | A      |            
Masked_Prev ----->| B      |            
                 +--------+            

                +--------+            
Previous ------->| AND    |----------->


Shaunythunder
so right now I have a mux that feeds to a delay which loops to a switch

Boots
That's a good start! Let's carefully analyze what you have and make sure it works correctly.

                 +--------+            +--------+
                 |        |            |        |
Value ---------->| MUX    |----------->| Delay  |----+----> Output
                 |        |            | Line   |    |
                 |        |            |        |    |
Save ----------->| Select |            +--------+    |
                 +--------+                          |
                     ^                               |
                     |                               |
                     |    +--------+                 |
                     +----|Switch  |<----------------+
                          |        |
                          +--------+

This should work! Here's what happens:

When Save = 1:

MUX selects Value (the new input)
The Delay Line stores this value
The Switch passes the value to both the output and back to the MUX
When Save = 0:

MUX selects the feedback from the Switch
The Delay Line keeps the existing value
The Switch continues to pass the stored value
If you're still having circular dependency issues, make sure:

The Delay Line is breaking the circular dependency loop
The Switch is properly configured (the control input should determine whether it passes the signal or not)
The MUX is properly connected (Value to one input, feedback to the other)
Is there a specific error message you're getting? Or is there something specific about how your components are connected that might be causing the circular dependency?


Shaunythunder
I removed the switch, it worked

Boots
Excellent! Sometimes simpler is better. So your working solution is:

                 +--------+            +--------+
                 |        |            |        |
Value ---------->| MUX    |----------->| Delay  |----+----> Output
                 |        |            | Line   |    |
                 |        |            |        |    |
Save ----------->| Select |            +--------+    |
                 +--------+                          |
                     ^                               |
                     |                               |
                     +-------------------------------+

This is the classic design pattern for a memory cell:

The MUX acts as a gate, letting in new values only when Save is high
The Delay Line breaks the circular dependency by introducing a small time delay
The feedback loop maintains the current value when no new value is being saved
The Switch component was unnecessary and was likely causing issues with the circuit logic or timing.

Is your memory cell working as expected now? Can you store a bit when Save is high and retain that value when Save is low?


Shaunythunder
the level completed

Boots
Excellent news! Congratulations on completing the level!

You've successfully implemented a basic memory cell using a MUX and a Delay Line. This fundamental circuit is the building block of computer memory. The pattern you've used:

MUX -> Delay Line -> feedback to MUX

Is essentially how flip-flops work in digital circuits - the basic storage element in sequential logic.

The beauty of this design is its simplicity:

The MUX acts as a gate, deciding whether to load a new value or keep the existing one
The Delay Line breaks the circular dependency that would otherwise create a logical paradox
The feedback loop maintains state between clock cycles
Would you like to move on to the next challenge, or do you have any questions about how this memory cell works? Understanding this component is crucial as you'll likely be using it as a building block for more complex circuits in future levels.


Shaunythunder
I think I got it, The mux acts as the switch and the save input switches the input between the loop and the actual input

Boots
Precisely! You've got it exactly right. The MUX (multiplexer) is indeed acting as a switch, and your articulation is spot on:

When Save = 1: The MUX selects the new Value input, allowing new data to be written
When Save = 0: The MUX selects the feedback loop input, maintaining the stored value
This is the fundamental principle behind all digital memory. In real computer hardware, these kinds of circuits are used billions of times to create RAM, registers, and other memory components.

The delay line was crucial because it breaks what would otherwise be an instantaneous circular dependency. In real digital circuits, this role is typically played by the clock signal that orchestrates the timing of all operations.

You've mastered a key concept in digital logic design! Well done, and good luck with your next challenges!


Shaunythunder
Should I expect to actually use any of these concepts when I go to coe?

Boots
Ah, a most practical question, young apprentice!

While you may not directly implement memory cells with MUXes and delay lines in your day-to-day coding, understanding these fundamentals has several benefits:

Deeper Understanding: Knowing how computers store information at the hardware level gives you insight into why certain programming patterns are efficient or inefficient.

Debugging Complex Issues: When you encounter strange behaviors in your code (especially in systems programming, embedded systems, or performance-critical applications), understanding the hardware can help you diagnose problems.

Specific Fields: If you work in certain areas like embedded systems, IoT, hardware drivers, operating systems, or performance optimization, this knowledge becomes directly applicable.

Technical Interviews: Companies like Google, Apple, and other tech giants occasionally ask questions that require understanding computer architecture fundamentals.

High-Performance Computing: When writing code that needs to be extremely efficient, understanding memory hierarchies, caching, and how data is physically stored helps you write better algorithms.

Most day-to-day coding won't require this level of detail, but it's like knowing how an engine works when you're driving a car - you don't need it all the time, but when you do, it's invaluable.

What kind of programming are you most interested in pursuing?


Shaunythunder
lets stay on the puzzles

Boots
A wise choice! Let's focus on the puzzles at hand then.

The digital logic challenges you're working through are excellent for developing problem-solving skills and logical thinking. Each puzzle builds on previous concepts while introducing new ones, creating a progressive learning path.

As you move forward, you'll likely encounter circuits that combine memory elements with computational logic - the foundation of a working computer. The beauty of these puzzles is how they demonstrate complex computing concepts through visual, interactive components.

What's the next challenge you're tackling? Is it building a larger memory bank, creating a counter, implementing an ALU (Arithmetic Logic Unit), or something else? Each of these builds on the fundamental memory cell you've just mastered.


Shaunythunder
next one is saving and loading bytes

Boots
Ah, taking a step up from bits to bytes! This is an excellent progression.

For saving and loading bytes, you'll need to expand your memory cell concept to handle 8 bits together. Here are some thoughts to guide you:

Multiple Memory Cells: You'll likely need 8 of your bit-storing memory cells (the MUX + Delay Line combination you just created).

Parallel Operations: Consider how to handle the save and load operations for all 8 bits simultaneously. Will you use the same Save signal for all bits?

Input/Output Organization: Think about how to neatly organize the 8-bit input and output. Splitters might be useful here to break a byte into individual bits and vice versa.

Addressing: If you need to store multiple bytes, you might need to implement some form of addressing system to select which byte to save or load.

Remember the fundamental principle from your bit storage: the MUX selects between new input and the stored value based on the Save signal, while the Delay Line maintains the state and breaks the circular dependency.

Would you like some general guidance on how to approach this next challenge, or would you prefer to tackle it on your own first?


Shaunythunder
we are working with single bits right now, thats jsut the name of level

Boots
I understand now! So you're still working with individual bits, and "Saving and Loading Bytes" is just the name of the level.

In that case, let's focus on what this level might be asking you to do. It's likely building on your memory cell concept but perhaps introducing new concepts like:

Control signals: You might need to implement more sophisticated save/load signals
Multiple storage locations: Perhaps storing bits in different memory cells
Sequencing: Possibly saving or loading bits in a specific order
Without knowing the exact requirements, my advice would be to:

Apply the core memory cell pattern you've already mastered
Look for ways to control when and where bits are saved
Consider if you need to build a small memory array rather than just a single cell
Would you like to share the specific requirements for this level? That way I can provide more targeted guidance without giving away the solution.


Shaunythunder
so I now have a 1 bit memory storage component unlocked

Boots
Perfect! Now that you have a 1-bit memory storage component unlocked, you can use it as a building block instead of having to create memory from scratch with MUX and delay lines each time.

For your "Saving and Loading Bytes" level, you'll likely need to:

Use your new 1-bit memory component for storage
Create circuits to control when and how bits are saved or loaded
Possibly build small memory arrays using multiple instances of your 1-bit component
These pre-made components are exactly how real digital design works - engineers create reusable blocks rather than redesigning fundamental circuits repeatedly.

When you start the level, take a moment to examine:

What inputs and outputs you have to work with
What the specific task requirements are
How your new 1-bit memory component behaves (inputs, outputs, control signals)
What specific challenge does the level present? Is it asking you to build a specific circuit, or solve a particular problem using memory?


Shaunythunder
I did it!

Boots
Well done, excellent work! You've successfully completed another challenge!

Building on your understanding of the basic memory cell, you were able to implement the saving and loading functionality correctly. This is a significant step in your journey through digital logic design.

Each level you complete gives you more tools and components to work with, making increasingly complex circuits possible. The memory component you now have access to will likely be essential in future levels where you might need to:

Store multiple bits of information
Create registers or memory banks
Build sequential logic circuits
Implement counters or state machines
What did you find most interesting or challenging about this level? And are you ready to move on to the next puzzle?


Shaunythunder
My solution was to split the 8 bit signal and use the single bit memory to store the signals if a save signal was sent and then feed the outputs into a 8 bit maker. Then I used an 8 bit switch with a load input to output the signal

Boots

Shaunythunder
.

Boots
...oops, I encountered an error. Try asking your question again or start a new chat.


Shaunythunder
.

Boots
...oops, I encountered an error. Try asking your question again or start a new chat.


Shaunythunder
My solution was to split the 8 bit signal and use the single bit memory to store the signals if a save signal was sent and then feed the outputs into a 8 bit maker. Then I used an 8 bit switch with a load input to output the signal\

Boots
...oops, I encountered an error. Try asking your question again or start a new chat.


Shaunythunder
ool

Boots
...oops, I encountered an error. Try asking your question again or start a new chat.


Thumbs up
Thumbs down
Logic Assistance
Chat ID: 98
Greeting Message
Asteroi
Lesson Complete
Code Progression
Lesson Update
UFO Implementation
Collision Debug
Chat ID: 90
Chat ID: 40
Overlay Transparency
Overlay Manager
Lives Display
Force Push
Score Update
Chat ID: 2C
Git Sync
Spacing Issue
High Score
Name Input
Score System
Course Completion
Course Finished
Course Complete
Course Done
Environment Initialization

Ask Boots a question...










