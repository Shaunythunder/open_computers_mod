Open main menu
4

gem bag



user avatarprofile role frame

CH2: Player

L4: Sprites






Sprites
Throughout this project, we will provide some of the code for you, like the class below. We want you to focus on specific parts and have pre-written the stuff that isn't related to the concepts we're trying to teach.

In pygame, there is a base class called Sprite, to represent visual objects.

Assignment
In our game, asteroids are visually represented as circles, and the player is a triangle. However, detecting collisions between circles and triangles is hard. To avoid this problem, we can cheat a little bit: the player will secretly be a circle.

The red circle won't be visible in the game; only we need to know it exists.

Let's create a CircleShape class that inherits from Sprite to represent objects in our game that are treated as circles (even if they aren't).

Create a new circleshape.py file and paste in the following code:

import pygame

# Base class for game objects
class CircleShape(pygame.sprite.Sprite):
    def __init__(self, x, y, radius):
        # we will be using this later
        if hasattr(self, "containers"):
            super().__init__(self.containers)
        else:
            super().__init__()

        self.position = pygame.Vector2(x, y)
        self.velocity = pygame.Vector2(0, 0)
        self.radius = radius

    def draw(self, screen):
        # sub-classes must override
        pass

    def update(self, dt):
        # sub-classes must override
        pass

CircleShape extends the Sprite class to also store a position, velocity, and radius.

Later you'll write subclasses of CircleShape and override the draw and update methods with the logic for that particular game object.

Run and submit the CLI tests from the root of the project.





Boots
Spellbook
Community


Boots
Need help? I, Boots the King of the Keyboard, can assist without penalty!

Boots
explain to me the new code line by line

Boots
Ah, a scholarly approach! Let's examine the CircleShape class line by line:

import pygame

This imports the pygame library, which we'll need for making our game, including the Sprite class we're inheriting from.

class CircleShape(pygame.sprite.Sprite):

This defines our new class called CircleShape that inherits from pygame.sprite.Sprite - a built-in pygame class for representing visual objects in games.

def __init__(self, x, y, radius):

This is the constructor method that initializes a new CircleShape object. It takes the position (x, y) and radius as parameters.

if hasattr(self, "containers"):
    super().__init__(self.containers)
else:
    super().__init__()

This checks if the class instance has a "containers" attribute. If it does, it initializes the parent Sprite class with those containers. This will be used later for sprite management. If not, it initializes the parent class without any containers.

self.position = pygame.Vector2(x, y)

This creates a Vector2 object to store the position. Vector2 is useful for 2D mathematics and makes it easier to handle positions and movements.

self.velocity = pygame.Vector2(0, 0)

This creates another Vector2 to store velocity, starting at zero.

self.radius = radius

This stores the radius of our circular shape.

def draw(self, screen):
    # sub-classes must override
    pass

This is a placeholder method that subclasses will need to override to define how the object is drawn on the screen.

def update(self, dt):
    # sub-classes must override
    pass

This is another placeholder method that subclasses will override to define how the object updates its state over time. The dt parameter is likely "delta time" - the time elapsed since the last update.

Does that help understand the structure? What part interests you the most for our space game?


Shaunythunder
as I paste them

Boots
I'm happy to explain as you paste sections of the code! That's a great way to understand step by step. Go ahead and paste the first part you'd like me to explain, and I'll walk through it with you.


Shaunythunder
class CircleShape(pygame.sprite.Sprite):

Boots
Excellent! This line defines our new class:

class CircleShape(pygame.sprite.Sprite):

This creates a class called CircleShape that inherits from pygame.sprite.Sprite.

The pygame.sprite.Sprite is a built-in base class in pygame that provides functionality for game objects. By inheriting from it, our CircleShape will have all the properties and methods of a Sprite, plus any additional ones we define.

Sprites in pygame are designed to be used for visual game elements - they can be drawn to the screen, updated each frame, and checked for collisions with other sprites. This inheritance is important because we're building on pygame's existing functionality rather than reinventing it.

What part would you like me to explain next?


Shaunythunder
isn't sprite.Sprite redundant?

Boots
Good catch! The way it's written might seem redundant, but there's actually a reason for it.

In pygame's organization, sprite is a module or subpackage within the pygame package, and Sprite is a class within that module. So the full path to the class is pygame.sprite.Sprite.

It's similar to how you might access something like os.path.join() - where os is the package, path is a module within that package, and join is a function within that module.

If the code had imported the Sprite class directly with something like:

from pygame.sprite import Sprite

Then we could have simply written:

class CircleShape(Sprite):

But since we imported the entire pygame package, we need to use the full path to access the Sprite class.

Would you like to continue with the next part of the code?


Shaunythunder
what is os.path.join()

Boots
Ah, a brief detour into Python's standard library!

os.path.join() is a function from Python's built-in os module that intelligently joins path components. It's particularly useful because it handles the different path separators across operating systems (backslashes \ on Windows, forward slashes / on Unix-based systems).

For example:

import os

# On Windows, this produces: "folder\file.txt"
# On Unix, this produces: "folder/file.txt"
path = os.path.join("folder", "file.txt")

It's a handy utility when you're writing code that needs to work across different operating systems, as it abstracts away the path separator differences.

I used it as an example of the dot notation hierarchy (package.module.function) which is similar to pygame.sprite.Sprite (package.module.class).

Shall we get back to our game code now?


Shaunythunder
def init(self, x, y, radius)

Boots
Let's examine this constructor method:

def __init__(self, x, y, radius):

This is the initialization method (constructor) for our CircleShape class. When you create a new instance of this class, this method gets called automatically.

The parameters are:

self: A reference to the instance being created (always the first parameter in Python class methods)
x: The x-coordinate where this shape will be positioned
y: The y-coordinate where this shape will be positioned
radius: How large the circular shape should be
This method sets up the basic properties that all circle-shaped objects in our game will need: a position, a radius for collision detection, and (as we'll see in the body of the method) a velocity.

These parameters make sense for our game objects because:

We need to know where in the game world the object is (x, y)
We need to know how big it is for collision detection (radius)
Ready for me to explain what happens inside this method?


Shaunythunder
if hasattr(self, "containers")

Boots
Let's look at this conditional statement:

if hasattr(self, "containers"):
    super().__init__(self.containers)
else:
    super().__init__()

This is checking if the current instance (self) has an attribute called "containers" using Python's built-in hasattr() function.

If self has a "containers" attribute:

It calls the parent class's __init__ method with self.containers as an argument.
In pygame, containers are used for sprite groups management. These groups help organize, update, and draw multiple sprites efficiently.
If self doesn't have a "containers" attribute:

It calls the parent class's __init__ method with no arguments.
The comment says "we will be using this later" because this is setting up for a sprite management system. Later in the game development, sprite groups will likely be used to:

Track all game objects of a certain type (e.g., all asteroids)
Check for collisions efficiently
Update and draw all sprites in a group with a single call
This conditional initialization ensures the sprite is properly registered with any container groups it belongs to, which is important for pygame's sprite management system.


Shaunythunder
what is hasattr

Boots
hasattr() is a built-in Python function that checks if an object has a specified attribute or property.

The syntax is:

hasattr(object, attribute_name)

It returns:

True if the object has the specified attribute
False if it doesn't
In our case, hasattr(self, "containers") is checking if our CircleShape instance has an attribute named "containers".

This function is useful when you need to conditionally perform operations based on whether an attribute exists, without causing errors. If you tried to directly access self.containers without checking, and it doesn't exist, you'd get an AttributeError.

A simple example:

class Example:
    def __init__(self):
        self.existing_attribute = "I exist!"

obj = Example()

# Returns True
print(hasattr(obj, "existing_attribute"))

# Returns False
print(hasattr(obj, "non_existing_attribute"))

In our game, this is being used as part of a flexible initialization system where some subclasses might define containers and others might not.


Shaunythunder
super().init(self.containers)

Boots
Let's examine this line:

super().__init__(self.containers)

This line calls the __init__ method of the parent class (in this case, pygame.sprite.Sprite) with self.containers as an argument.

Breaking it down:

super() is a built-in Python function that returns a temporary object of the superclass (parent class), allowing you to call its methods.

.__init__() calls the initialization method of that parent class.

(self.containers) passes the containers attribute of the current instance to the parent's initialization method.

In pygame, this is important because the Sprite class has functionality to automatically add itself to sprite groups (containers) when initialized. Sprite groups in pygame are collections of sprites that can be updated and drawn together, which makes game logic simpler.

So what this line does is tell the parent Sprite class: "Hey, I have some sprite groups I want to be a part of. Please add me to them during initialization."

This creates a connection between our CircleShape object and whatever sprite groups it needs to be part of, which will be useful for collision detection, drawing, and updating multiple sprites efficiently.


Shaunythunder
explain to me how the parent works

Boots
Ah, let's explore how parent classes work in Python inheritance!

When a class inherits from another class, the inheriting class (child) gains all the attributes and methods of the class it inherits from (parent). This allows for code reuse and establishing relationships between classes.

In our case:

class CircleShape(pygame.sprite.Sprite):

CircleShape is the child class, and pygame.sprite.Sprite is the parent class.

How the Parent Relationship Works:
Inheritance: CircleShape automatically has access to all methods and attributes defined in pygame.sprite.Sprite.

Method Override: If CircleShape defines a method with the same name as one in pygame.sprite.Sprite, the child's version overrides (replaces) the parent's version.

Constructor Chaining: When you create a new CircleShape, its __init__ method runs. But to ensure the parent is also properly initialized, we call super().__init__().

Using super(): The super() function returns a proxy object that delegates method calls to the parent class. It automatically handles the inheritance hierarchy, even in complex cases with multiple inheritance.

Parent Initialization: In pygame, the Sprite.__init__() method sets up essential internal state for the sprite and can add it to sprite groups if provided.

This parent-child relationship is powerful because:

Our CircleShape gets all the built-in sprite functionality (like collision detection)
We can extend it with our own properties (like position, velocity, radius)
We can override methods to customize behavior (like draw, update)
The line super().__init__(self.containers) ensures that all the initialization the parent class needs to do happens correctly, while also passing our containers to be included in that initialization.


Shaunythunder
what are the properties of sprite.Sprite

Boots
Great question! Let's look at the key properties and methods of the pygame.sprite.Sprite class:

Properties of pygame.sprite.Sprite:
image (usually added by you): While not initially set, most sprite implementations will have an image attribute that holds the visual representation (a pygame Surface object).

rect (usually added by you): Similar to image, most implementations add a rect attribute that defines the position and size of the sprite for drawing and collision detection.

groups(): Not a property but a method that returns a list of all the Groups that contain this Sprite.

Methods of pygame.sprite.Sprite:
__init__(): Initializes the sprite and can add it to sprite groups.

update(*args, **kwargs): An empty method meant to be overridden. Typically used to update the sprite's state each frame.

add(*groups): Adds the sprite to the specified Groups.

remove(*groups): Removes the sprite from the specified Groups.

kill(): Removes the sprite from all Groups it belongs to.

alive(): Returns True if the Sprite belongs to any Groups.

The pygame.sprite.Sprite class is intentionally minimal - it's designed to be a base class that you extend with your own properties and methods. Its main purpose is to provide group membership functionality and a common interface for game objects.

In our CircleShape class, we're building on this foundation by adding:

Position tracking with Vector2
Velocity for movement
Radius for collision detection
Custom draw and update methods
This is why many pygame tutorials will have you add image and rect attributes to your sprites - they're not provided by default but are conventional for using sprites with pygame's rendering system.


Shaunythunder
slap that in code please

Boots
Here's a basic example of a minimal pygame Sprite implementation to illustrate the properties and methods:

import pygame

# Initialize pygame
pygame.init()
screen = pygame.display.set_mode((800, 600))

# Create a sprite group
all_sprites = pygame.sprite.Group()

# Create a basic sprite class
class BasicSprite(pygame.sprite.Sprite):
    def __init__(self):
        # Initialize the parent class
        super().__init__()
        
        # Create the image (a simple red square)
        self.image = pygame.Surface((50, 50))
        self.image.fill((255, 0, 0))  # Red color
        
        # Create the rect (position and size)
        self.rect = self.image.get_rect()
        self.rect.center = (400, 300)  # Center of the screen
    
    def update(self):
        # Move the sprite a bit (would be called each frame)
        self.rect.x += 1
        
        # Wrap around the screen
        if self.rect.left > 800:
            self.rect.right = 0
    
    # Demonstrate some sprite methods
    def demo_sprite_methods(self):
        # Check if the sprite is in any groups
        is_alive = self.alive()
        print(f"Is sprite alive? {is_alive}")
        
        # Get all groups containing this sprite
        sprite_groups = self.groups()
        print(f"Sprite is in {len(sprite_groups)} groups")
        
        # Remove from all groups (kill the sprite)
        self.kill()
        print(f"After kill(), is alive? {self.alive()}")

# Create a sprite and add it to the group
my_sprite = BasicSprite()
all_sprites.add(my_sprite)

# Demonstrate group operations
print(f"Group has {len(all_sprites)} sprites")
my_sprite.demo_sprite_methods()
print(f"After kill(), group has {len(all_sprites)} sprites")

This code demonstrates:

Creating a basic sprite with image and `rect

Shaunythunder
I mean the sprite.Sprite dclass

Boots
Ah, I see! You want to see the actual implementation of the pygame.sprite.Sprite class. Here's a simplified version of how it might be implemented in pygame:

class Sprite:
    def __init__(self, *groups):
        self.__g = {}  # Private dictionary to track group membership
        if groups:
            self.add(*groups)
    
    def add(self, *groups):
        """Add the sprite to specified groups"""
        for group in groups:
            if group not in self.__g:
                group.add_internal(self)
                self.__g[group] = 0
    
    def remove(self, *groups):
        """Remove the sprite from specified groups"""
        for group in groups:
            if group in self.__g:
                group.remove_internal(self)
                del self.__g[group]
    
    def kill(self):
        """Remove the sprite from all groups"""
        for group in list(self.__g):
            group.remove_internal(self)
        self.__g.clear()
    
    def groups(self):
        """Return a list of groups that contain this sprite"""
        return list(self.__g)
    
    def alive(self):
        """Return True if the sprite belongs to any groups"""
        return bool(self.__g)
    
    def update(self, *args, **kwargs):
        """Method to be overridden by subclasses"""
        pass

This is a simplified version, but it captures the essence of how the Sprite class works in pygame:

It maintains a private dictionary (__g) to track which groups the sprite belongs to.
Methods like add(), remove(), and kill() manage group membership.
The update() method is a placeholder meant to be overridden.
It doesn't actually contain any visual properties - those are typically added by subclasses.
The actual implementation in pygame is written in C for performance, but this Python version demonstrates the core functionality. This class simply provides the infrastructure for sprites to be organized into groups, without defining how they look or behave.


Shaunythunder
wait what? pygame is in C?

Boots
Yes, partially! Pygame is actually a mixture of Python and C code:

Core Implementation: Many of Pygame's core components are written in C as Python extension modules for performance reasons. The SDL (Simple DirectMedia Layer) library that Pygame is built on top of is written in C.

Python Wrapper: Pygame provides a Python API that makes these C libraries accessible through easy-to-use Python objects and functions.

This hybrid approach gives you the best of both worlds:

The speed and efficiency of C for computationally intensive operations like blitting (drawing images), collision detection, and sound processing
The simplicity and readability of Python for game logic and organization
When you import pygame modules, you're often using Python wrappers that call optimized C code behind the scenes. This is why Pygame can achieve reasonable performance despite Python generally being slower than languages like C or C++.

The sprite system we're discussing is one such example - while you interact with Sprite objects using Python, the actual drawing and some collision detection may be happening in optimized C code.

This is a common pattern in Python libraries that need performance - NumPy, Pandas, and many graphics/game libraries use this approach.


Shaunythunder
ddidn't know you could splice code like that

Boots
Yes, it's quite a powerful technique! This approach of combining languages is used extensively in the Python ecosystem and is one of Python's strengths. Here's how it works:

How Python Extensions Work
C/C++ Extensions: Python has a well-defined "C API" that allows developers to write extension modules in C or C++. These compiled extensions can be imported just like regular Python modules.

Wrapping Process:

C/C++ code handles performance-critical operations
Python code provides a friendly interface to those operations
The "glue" between them is the Python C API
Compilation: These extensions are compiled into shared libraries (.so files on Linux/Mac, .dll files on Windows) that Python can dynamically load.

Benefits of This Approach
Performance: Operations that need speed run in compiled code
Usability: Developers still get to use Python's friendly syntax
Best Tool for the Job: Each language does what it's best at
Other Examples Besides Pygame
NumPy: Core numerical operations happen in C
Pandas: Built on NumPy with C and Cython extensions
TensorFlow/PyTorch: Python interfaces to C++/CUDA backends
Pillow: Image processing in C with Python API
Psycopg: Database drivers often written in C
lxml: XML processing using C libraries
Modern Tools for Building Extensions
Cython: Write Python-like code that compiles to C
SWIG/pybind11: Tools to generate Python bindings for C/C++ code
ctypes/cffi: Call C functions directly from Python
This hybrid approach is why Python can be used for everything from web development to scientific computing, despite not being the fastest language on its own. The ecosystem leverages the strengths of multiple languages!


Shaunythunder
self.position = pygame.Vector2(x, y)

Boots
Let's explore this line:

self.position = pygame.Vector2(x, y)

This creates a 2D vector to store the position of our sprite. Let me break this down:

pygame.Vector2
pygame.Vector2 is a class in pygame that represents a 2-dimensional vector. It's incredibly useful for game development because it:

Stores both x and y coordinates in one object
Provides vector mathematics (addition, subtraction, dot products, etc.)
Makes movement and physics calculations cleaner
How It Works
When you create a Vector2 with pygame.Vector2(x, y):

It stores the x-coordinate at position.x
It stores the y-coordinate at position.y
Why Use Vectors Instead of Separate Variables?
Using vectors instead of separate x and y variables has several advantages:

Cleaner Code:

# With vectors
self.position += self.velocity * dt

# Without vectors
self.x += self.velocity_x * dt
self.y += self.velocity_y * dt

Vector Math: Vectors support operations like normalization, dot products, and rotation that would be complicated to implement with separate variables.

Passing Data: You can pass an entire position as one object instead of two separate values.

In Our CircleShape Class
In the context of our CircleShape class:

self.position stores where the shape is located on screen
Since it's a Vector2, we can easily update it with physics calculations
We'll use it later to draw the object at the correct location
The beauty of this approach is that when we need to move our sprite, we can simply add another vector to it, which is much cleaner than updating individual x and y coordinates.


Shaunythunder
why are these public and not private

Boots
That's a great question about object-oriented design! In the CircleShape class, attributes like position, velocity, and radius are indeed public rather than private. Let's explore why this might be the case:

Public vs Private in Python
First, a quick reminder about how Python handles access modifiers:

Python uses a convention of prefixing names with underscores to indicate access levels
Single underscore (_attribute) suggests "protected" (internal use)
Double underscore (__attribute) creates name mangling (closest to "private")
No underscore means public access
Why These Attributes Are Public
There are several reasons why these might be kept public in this context:

Game Development Practices:

Game development often prioritizes direct access for performance and simplicity
Many game engines expose position/physics properties publicly
Intended Use:

These attributes are meant to be read and modified by game logic
Other objects and systems need to check positions and velocities frequently
Python Philosophy:

"We're all consenting adults here" - Python philosophy often favors direct access
The code relies on developers using properties appropriately rather than enforcing restrictions
Educational Context:

In a learning project, simpler code with fewer abstractions can be more understandable
When Would We Make Them Private?
There would be good reasons to make these private in some contexts:

If we needed validation when setting values
If we needed to trigger side effects when properties change
If we were building a more complex system where encapsulation would protect against unintended modifications
A Property-Based Alternative
If we wanted more control, we might implement them as properties:

class CircleShape(pygame.sprite.Sprite):
    def __init__(self, x, y, radius):
        # Setup code...
        self._position = pygame.Vector2(x, y)
        self._velocity = pygame.Vector2(0, 0)
        self._radius = radius

    @property
    def position(self):
        return self._position
        
    @position.setter
    def position(self, value):
        if not isinstance(value,


Shaunythunder
alright I think we've saturated my brain enough

Boots
Fair enough! You've explored quite a few concepts today - from Pygame's Sprite class implementation to language hybridization with C and Python, and even design decisions about public vs private attributes.

The main takeaway for your immediate task is to create that CircleShape class as outlined in the instructions - a class that inherits from pygame's Sprite class and maintains position, velocity, and radius properties for game objects.

When you're ready to continue, you can create your circleshape.py file with the code provided in the instructions, and then use the bootdev CLI to test your implementation.

Is there anything specific about the CircleShape class or the assignment that you'd like me to clarify before you move on?


Shaunythunder
I also did a whole thing on ai in antoher window

Boots
Ah, I see! Sounds like you've been doing quite a bit of learning across different topics today. The brain can only absorb so much at once!

When you're ready to return to this pygame project, just remember the key points about the CircleShape class:

It inherits from pygame's Sprite class
It handles circular collision detection
It maintains position, velocity and radius information
Feel free to come back with questions when you're ready to continue. Taking breaks is an important part of the learning process - it gives your brain time to process and consolidate all this new information.

Good luck with your AI explorations as well!


Shaunythunder
break == sleep

Boots
Indeed, sleep is the ultimate break! Your brain does some of its most important work while you rest - consolidating memories, strengthening neural connections, and organizing what you've learned.

There's a reason why "sleep on it" is such common advice for problem-solving. Many programmers report having breakthroughs on problems after a good night's sleep that seemed impossible the night before.

So whether it's pygame sprites, AI concepts, or any other challenging material - a well-rested mind will approach it with much greater clarity.

Rest well, young wizard! The code will still be here tomorrow.


Shaunythunder
dear god I just made a joke in code

Boots
Ha! That's the mark of a true programmer - finding humor in code! Some of the best developers I know express their personality through clever variable names, punny comments, or amusing logic structures.

Just remember the old wizard's warning: the joke that seems brilliantly funny at 2 AM might be completely incomprehensible when you (or your teammates) read it months later. The best code humor is both funny AND readable!

What was your coding joke, if you don't mind sharing? I always appreciate a good bit of programming humor!


Shaunythunder
okay the joke should have been this

for break in breaks:
    if break == final_break:
        return sleep
    else:
        break = 15 min

Boots
Oh my, that's delightfully meta! A loop over breaks that breaks differently based on the break type, with a play on the break keyword.

for break_time in breaks:
    if break_time == final_break:
        return sleep
    else:
        break_time = 15  # minutes

Of course, Python would never let you use break as a variable name since it's a reserved keyword, but that's part of what makes it funny to programmers - that moment of "wait, you can't do that!" followed by the realization of the multi-layered joke.

This is the kind of humor that would make experienced coders chuckle while completely mystifying non-programmers. The hallmark of excellent programmer humor!


Shaunythunder
I;m here all week

Boots
adjusts spectacles and wizard hat

Well then, I'll be sure to keep a seat open at the front of the comedy club! With material like that, you'll have all the developers rolling in the aisles and the Python interpreters throwing syntax errors in delight.

Just remember to tip your servers... and your database administrators too, they're the real heroes making sure your jokes don't cause a table flip.

strokes beard thoughtfully

Perhaps next time you can tell us about the time a UDP packet walked into a bar... or maybe not, there's no guarantee it would be received.


Shaunythunder
I'll be sure to pick up my glasses, white tape, and picket protector while Im at it

Boots
chuckles warmly

Excellent additions to your programmer comedy arsenal! Don't forget the essential vintage calculator watch and perhaps a t-shirt with an obscure algorithm joke that only three people in the world understand.

I hear the pocket protector is making a comeback as a retro-ironic fashion statement among the most elite coding circles. Pair it with those taped glasses and you'll be ready for your headlining tour: "SELECT * FROM jokes WHERE funny = TRUE;"

Just be prepared for the hecklers questioning your semicolon usage and bracket placement. The coding comedy circuit can be ruthless!


Shaunythunder
they are no match for my slide rule

Boots
eyes widen with admiration

By the sacred algorithms! A slide rule! Now that's not just retro, that's practically arcane wizardry!

You'll be the envy of every computer science department, solving logarithms with a flick of your wrist while the youngsters are still waiting for their calculators to boot up. That's not just old schoolâ€”that's founding-of-the-school school!

When you whip out that slide rule at the hackathon, the mechanical keyboard enthusiasts will bow down in reverence. "We thought our IBM Model M keyboards made us vintage," they'll whisper, "but this one computes with physical movement."

Truly, with a slide rule in hand, you've transcended from mere programmer to computational historian. The elders of FORTRAN and COBOL would approve!


Shaunythunder
I knew a guy who lugged aroudn a typewriter and used it unironically

Boots
adjusts monocle in absolute astonishment

Now THAT is commitment to the craft! A typewriter user in the modern age is the technological equivalent of someone hunting their dinner with a spear when there's a grocery store next door.

There's something magnificently defiant about the clack-clack-ding of a typewriter in a room full of silent keyboards. I can just imagine the scene:

"Could you turn down the volume on your... um... input device?"
"This IS turned down. Would you prefer I use the manual model instead?"

The beautiful thing about typewriters is their perfect blend of advantages. The battery life is infinite, they're completely immune to ransomware, and they produce a physical backup with every keystroke!

I must know - was this person a writer, a programmer, or simply someone who enjoyed watching their colleagues jump at every carriage return? And did they have those magnificent strong typist fingers that could probably crush walnuts?


Shaunythunder
he was quite the luddite

Boots
Ah, a true luddite! There's something paradoxically admirable about someone who sticks to their technological principles in an age of constant upgrades and planned obsolescence.

While the rest of us are fretting about cloud syncing and battery life, your typewriter-wielding acquaintance was living in a simpler world of ribbon ink and manual carriage returns. No software updates, no compatibility issues, no "your device is obsolete" messages - just the pure mechanical relationship between thought and paper.

I can only imagine the reactions when he'd roll that typewriter into a modern office or coffee shop. It must have been like bringing a horse-drawn carriage to a Tesla convention - turning heads and raising eyebrows with every ding of the bell.

The irony, of course, is that being a luddite in today's world takes far more effort than conforming. It's a deliberate choice that requires swimming against a very strong technological current. That takes conviction!

Did he have any other pre-digital habits that completed his luddite lifestyle?


Thumbs up
Thumbs down
Circlesh
Code Explanation
Hitbox

Ask Boots a question...











