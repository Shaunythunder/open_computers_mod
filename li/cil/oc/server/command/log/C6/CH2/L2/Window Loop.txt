Open main menu
4

gem bag



user avatarprofile role frame

CH2: Player

L2: Game Loop






Game Loop
Video games are generally built using a game loop. The simplest game loop has 3 steps:

Check for player inputs
Update the game world
Draw the game to the screen
To create a good user experience, these 3 steps need to happen many times per second.

Assignment
import pygame at the top of your main.py file. The pygame documentation will be super useful throughout this project.
Initialize pygame at the beginning of your main() function (take a look at the docs for the syntax).
Ensure our predefined constants (constants.py) SCREEN_WIDTH and SCREEN_HEIGHT are imported at the top of your file:
from constants import *

Because this is a smaller project, and we don't risk conflicting import names, we're going to use a wildcard import for convenience. In a larger project, you'd want to import only the constants you need.

Use pygame's display.set_mode() to get a new GUI window:
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

Create the game loop. For now, we'll only worry about step 3: drawing the game onto the screen.
Use an infinite while loop for the game loop. At each iteration, it should:
Use the screen's fill method to fill the screen with a solid "black" color.
Use pygame's display.flip() method to refresh the screen. Be sure to call this last!
It's a good idea to run and test your game frequently as you write code , to make sure it's working as expected:
If you're on a mac, wait until step 8 before doing this.
uv run main.py

You should see a black window open and stay open.

Close the game and kill the program with Ctrl+C in the terminal.
Add the following code to the beginning of each iteration of the game loop:
for event in pygame.event.get():
    if event.type == pygame.QUIT:
        return

This will check if the user has closed the window and exit the game loop if they do. It will make the window's close button work.

Make a git commit! It's a good idea to commit your progress whenever you get something new working.
With the window painting black and closing properly, you're ready to move on to the next step!



Solution Files





Boots
Spellbook
Community


Boots
Need help? I, Boots the King of the Keyboard, can assist without penalty!

Boots
while True:
for event in pygame.event.get():
if event.type == pygame.QUIT:
return

why isn't the window staying open

Boots
Ah, let's ponder this conundrum together! Your while True loop and the event handling seem correct at a first glance, but I can't help but notice a potential issue.

The use of return inside the if event.type == pygame.QUIT will exit the main() function (or wherever this loop resides), terminating the program.

Are you calling this loop inside a function, such as main()? If so, when return is executed, it will stop the function entirely, causing the program to exit—hence, the window closes.

To fix this, you could use break to exit only the loop, but allow the program to continue running properly. For example:

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            break

Alternatively, you could modify it to cleanly terminate by exiting the loop and optionally calling pygame.quit() afterward.

Does this align with your code structure? If not, can you share how this loop is placed in your program?


Shaunythunder
the program crashes with the original code

Boots
Hmm, a crash, you say? Let’s carefully examine what could cause such mischief in the code.

A few possibilities come to mind:

pygame.init() missing:
Have you initialized pygame at the start of your program with pygame.init()? The pygame.event.get() function depends on the library being properly initialized. Forgetting this could cause the program to crash.

No display has been set:
Before diving into the game loop, have you used pygame.display.set_mode() to set up the game window? For example:

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

Without a screen initialized, the program might not handle events properly.

Errors not shown:
There could be some underlying exception causing the crash. Are you seeing any error messages in the terminal? If not, try running the program in debug mode or scrutinize the logs.

If we verify those steps but the crash persists, we may need to inspect the rest of your setup. Tell me, does your code include the parts where the screen is created (pygame.display.set_mode(...)) and pygame.init() is called? Walking through your complete initialization might reveal the root cause.


Shaunythunder
import pygame
from constants import * # Everything

def main():

# Print starting messages
print("Starting Asteroids!")
print(f"Screen width: {SCREEN_WIDTH}")
print(f"Screen height: {SCREEN_HEIGHT}")

pygame.init()
pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.fill("black")

# Game loop start
while True:
	for event in pygame.event.get():
		if event.type == pygame.QUIT:
			return
	

# Keep this last
pygame.display.flip()

if name == "main":
main()

Boots
Aha! Upon inspecting your code, I notice a sneaky little problem that must be addressed. The crash is likely caused by the fact that the pygame.fill("black") method is incorrectly placed. You’re trying to call fill directly on pygame, but fill is not a global function—it is a method that needs to be used on the Surface object returned by pygame.display.set_mode().

When you call pygame.display.set_mode(...), it returns a Surface object that represents the screen. To fill the screen with a color, you need to call fill on that Surface object, not on pygame itself.

Here’s the fix:

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Save the surface in a variable
screen.fill("black")  # Now call fill on the screen surface

Revised main() function:

def main():
    # Print starting messages
    print("Starting Asteroids!")
    print(f"Screen width: {SCREEN_WIDTH}")
    print(f"Screen height: {SCREEN_HEIGHT}")

    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Store the Surface
    screen.fill("black")  # Properly fill the screen with color

    # Game loop start
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return

        # Update the actual display
        pygame.display.flip()

Now, try running it again. The window should appear and stay open with a black background. Does this resolve your issue? What other unexpected behavior do you observe?


Shaunythunder
pygame 2.6.1 (SDL 2.28.4, Python 3.12.3)
Hello from the pygame community. https://www.pygame.org/contribute.html
Starting Asteroids!
Screen width: 1280
Screen height: 720
Traceback (most recent call last):
File "/home/shame/workspace/github.com/boot_dev/cirriculum/asteroids_game/main.py", line 23, in <module>
main()
File "/home/shame/workspace/github.com/boot_dev/cirriculum/asteroids_game/main.py", line 13, in main
pygame.fill("black")
^^^^^^^^^^^
AttributeError: module 'pygame' has no attribute 'fill'

Boots
Ah, the error message confirms what I suspected, young coder! The issue is indeed with your call to pygame.fill("black"). As I mentioned earlier, the fill method doesn't exist on the pygame module itself; it belongs to a Surface object, such as the one returned by pygame.display.set_mode().

Let's revisit how to handle this correctly.

In your code, you should store the result of pygame.display.set_mode(...) in a variable, like screen, and then call the fill method on that. Here's the corrected section:

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Create and store the screen surface
screen.fill("black")  # Fill the screen surface with black

Full corrected main() function:

def main():
    # Print starting messages
    print("Starting Asteroids!")
    print(f"Screen width: {SCREEN_WIDTH}")
    print(f"Screen height: {SCREEN_HEIGHT}")

    # Initialize pygame
    pygame.init()
    
    # Set up the display
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Surface object
    screen.fill("black")  # Properly fill the screen with black

    # Game loop start
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return  # Exit the program gracefully

        # Refresh the display
        pygame.display.flip()

This adjustment ensures that you're correctly interacting with the Surface returned by pygame.display.set_mode().

Now, try running the program again. Does the window open and display the intended black background? If not, let me know and we can keep exploring together!


Shaunythunder
pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)).fill("black")

Boots
Ah, well spotted! It seems you've combined the call to pygame.display.set_mode() and the fill() method, all in one line. This will indeed work properly—you're chaining the method directly after creating the screen. However, this approach has a small drawback: you're not storing the screen's surface in a variable, making it inaccessible later if you need to draw or manipulate it further.

Why You Should Store screen
If you follow the line:

pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)).fill("black")

You're filling the screen with black, but you have no easy way to access that Surface object (screen) again afterward. For a more flexible program, you'll typically want to store the screen like this:

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
screen.fill("black")

When Your Version Can Be Used
If you're absolutely certain you never need to reference the screen object again in your code, combining it like this may be fine. But in games, you'll often need further interaction, like drawing images, text, or handling more than just a static background! So it's a good habit to keep screen in a variable.

What do you think? Would you like to proceed with this cleaner, more reusable version?


Shaunythunder
so would I store that as a local or global

Boots
Excellent question, aspiring wizard of code! Deciding between a local or global variable depends on how you expect to use the screen in your program.

Local Variable:
If your game loop and related rendering code (drawing objects, text, etc.) are all contained within the same function (like main()), then storing screen as a local variable is the better choice. Local variables are generally cleaner, easier to manage, and less prone to unintended side effects.

For example:

def main():
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Local
    screen.fill("black")  # Use it locally here

    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return

        # Refresh the display
        pygame.display.flip()

Global Variable:
On the other hand, if your program is more complex—say, it's spread across multiple functions or modules—and you need to access screen from multiple places, then using a global variable might seem tempting. However, globals can lead to bugs and make your program harder to maintain as it grows.

Instead of making screen truly global, consider passing it explicitly to other functions that require it. This keeps things tidy and keeps control of who can modify the screen.

For example:
def main():
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Still local to main()

    game_loop(screen)  # Pass it to another function

def game_loop(screen):
    screen.fill("black")  # Accessible because it's passed explicitly
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return

        pygame.display.flip()

Summary:
Local Variable: Best for simpler programs where all logic is contained in one place.
Pass Around Explicitly: Best practice for more complex programs. It's cleaner than making screen global.
Global Variable: Avoid if possible, as it can make debugging nightmarish.
How complex do you envision your game becoming? Should we discuss the best approach based on how you're organizing your project?


Shaunythunder
so you would pass it as an arg

Boots
Ah, indeed, astute learner, passing the screen as an argument is a splendid approach! It keeps your code clean, manageable, and free of global entanglements. By doing so, each function that needs to draw or interact with the screen can receive it as a parameter—maintaining clarity and reducing unintended side effects.

For example, imagine we want to separate concerns by delegating tasks like rendering a background to another function. Here’s how you might approach it:

Passing screen as an Argument:
def main():
    pygame.init()

    # Initialize the screen
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

    # Start the game loop, passing the screen
    game_loop(screen)

def game_loop(screen):
    # Fill the screen once at the beginning
    screen.fill("black")

    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return

        # Example placeholder for future drawing code
        draw_game(screen)

        # Flip the display to update the screen
        pygame.display.flip()

def draw_game(screen):
    # At each frame, you could draw objects or UI here
    # E.g., draw a rectangle:
    pygame.draw.rect(screen, (255, 0, 0), (50, 50, 100, 100))  # A red rectangle

Why is this passing strategy so clever?
Modularity: Each part of your program (e.g., game loop, drawing functions) is now nicely encapsulated.
Ease of Testing: Individual functions can now be tested with screen mocked or passed explicitly, making debugging easier.
Readability: The flow of information between functions is clear—no mysterious global variables altering the screen without notice.
By passing screen as an argument, your code remains flexible as it grows, reducing the temptation to make everything global.

Do you have any other functions you'd like to build that might benefit from this approach? Perhaps we can plan how your game will render additional objects or handle input?


Shaunythunder
I feel like that would complicate things if I have 20 args

Boots
Ah, wise observation! You are correct—passing 20 arguments to a function could quickly make things unwieldy and confusing! If you're finding yourself needing to pass a multitude of variables around, this might indicate it's time to refactor your design.

Rather than passing numerous arguments directly, consider grouping related components together. Here are some approaches to handle complexity gracefully:

1. Use a Game State Class or Object
When working with games, it's a common pattern to create a Game class (or similar) that stores the important variables, like screen, player stats, enemies, etc. Then, you can pass around the entire Game object where needed, instead of passing each piece individually.

For example:

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.running = True  # A flag to control the game loop
        self.clock = pygame.time.Clock()  # For managing frame rates

def main():
    game = Game()  # Initialize the game state

    while game.running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                game.running = False  # Update the game state

        draw_game(game)  # Pass the game object to other functions
        pygame.display.flip()
        game.clock.tick(60)  # Limit to 60 frames per second

def draw_game(game):
    game.screen.fill("black")  # Use the screen from the passed game object
    pygame.draw.circle(game.screen, (0, 255, 0), (200, 200), 50)  # Draw a green circle

By putting all your shared variables in a single class or object (Game here), you both simplify argument passing and make it easy to expand the game in the future. Need to add player stats, inventory, or level data? You can store it all in the Game class.

2. Use a Dictionary for Shared State
If you don’t want to define a full class, you can create a dictionary to group related variables and pass it:

def main():
    game_state = {
        "screen": pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)),
        "running": True,
    }

    while game_state["running"]:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                game_state["running"]


Shaunythunder
would about just using the local variable

Boots
Ah, a sensible thought! For many cases, simply keeping screen or other variables as local to the main() function (or wherever they’re created) can absolutely work. This is especially practical when your game loop and related logic are all contained in one place.

If all the logic for rendering, input handling, and game state updates resides in the same scope, a local variable can simplify things. Let's revisit a scenario where everything is kept local:

Example: Keeping screen Local
def main():
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Local variable
    clock = pygame.time.Clock()  # Local variable for managing frame rates

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        # Drawing everything
        screen.fill("black")  # Use the local `screen`
        pygame.draw.circle(screen, (0, 255, 0), (200, 200), 50)  # A green circle
        pygame.display.flip()

        clock.tick(60)  # Limit to 60 FPS

# Call the main function to start the game
main()

Pros of Keeping It Local
Simple and Easy to Follow: If all your game logic exists within the same function or tightly controlled scope, there's no need to over-engineer. Local variables won't clutter your namespace or require complicated passing.
No Additional Setup: You don’t need to define classes or data structures unless your game becomes more complex.
Avoids Global Variables: The scope is limited to main() or the enclosing function, preventing unintended access or modification elsewhere in your program.
When This Approach Becomes Limiting
While keeping variables local works well for simpler projects, if your game grows and you split functionality across multiple functions or modules (e.g., a render() function, or handle_input() function), things can get messy. You might end up passing multiple local variables between functions repeatedly, which can quickly become cumbersome.

A local-only solution is best suited for:

Small games or prototypes that aren’t too complex.
Programs where all or most logic resides in a single function.
A Question for Reflection:
How complex do you think your game might get? If you envision only simple drawing and logic, sticking


Shaunythunder
continue

Boots
Ah, wonderful! Let's continue where we left off.

If you envision only simple drawing and logic, sticking with local variables makes perfect sense. But, if you plan for your game to grow—adding new features like animations, multiple levels, or complex interactions between objects—you may eventually need to revisit your approach to avoid unwieldy code.

So let's step back for a moment and reflect:

Will your game stay small and self-contained?
Keep it simple. Using local variables within one function (e.g., main()) is fine!
Will your game expand, with numerous functions or modules responsible for different parts?
Centralizing shared data in a class or object might save you trouble later.
Here’s how the local variable approach would work even with small-level expansion:

Extending with Local Variables Using Small Functions
You could still stick to local variables but carefully organize your code by calling helper functions from your main() function. Here's an example:

def main():
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Local variable
    clock = pygame.time.Clock()
    running = True

    while running:
        running = handle_events()  # Event handling
        update_game()  # Game world updates (empty for now)
        draw_game(screen)  # Draw everything, passing `screen` locally

        pygame.display.flip()
        clock.tick(60)


def handle_events():
    # Manage input and events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            return False
    return True


def update_game():
    # Update game state (player, enemies, etc.)
    pass


def draw_game(screen):
    # Handle all drawing
    screen.fill("black")
    pygame.draw.circle(screen, (0, 255, 0), (200, 200), 50)  # A green circle

Why Does This Work Well?
All variables (screen, clock, etc.) remain local to main().
Functions like handle_events() or draw_game() are independent and receive only what they need (e.g., screen for drawing).
Keeps your code modular and readable while maintaining simplicity.
When Local Becomes Too Much
If you’re finding yourself juggling 10+ arguments (e.g., screen, clock, player position, enemies,


Shaunythunder
okay lets stick to local for this project

Boots
A fine decision, noble coder! Keeping things local is an excellent choice for a small and focused project—it simplifies your workflow and keeps your mind uncluttered, like a wizard's workshop with only the most essential spellbooks.

Would you like to walk through your game loop and ensure everything's functioning locally as it should? Or do you have specific questions about the screen, game logic, or event handling? Let me know where you'd like to focus your magic!


Shaunythunder
import pygame
from constants import * # Everything

def main():
# Variable definitions
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

# Print starting messages
print("Starting Asteroids!")
print(f"Screen width: {SCREEN_WIDTH}")
print(f"Screen height: {SCREEN_HEIGHT}")

# Pygame start
pygame.init()
screen.fill("black")

# Game loop start
while True:
	for event in pygame.event.get():
		if event.type == pygame.QUIT:
			return
	

# Keep this last
pygame.display.flip()

if name == "main":
main()

what do you think

Boots
Ah, apprentice, this is a strong foundation indeed! Your local variable management looks admirably tidy, and the structure of your main() function is well-organized. However, I sense some areas that could use a sprinkle of refinement for robustness and completeness. Let us review it step-by-step!

1. pygame.init() Needs to Happen Early
You’ve placed pygame.init() after defining screen, which is a bit out of order. Initializing pygame before using its features (like set_mode) is considered best practice. Otherwise, issues might arise since pygame isn’t fully initialized when you try to create the screen.

Simply move pygame.init() right to the top of your main() function.

2. “fill” Before Loop isn't Useful Here
You’re already calling screen.fill("black"), but this only fills the screen one time, right after creating it. Unfortunately, since it's not in the game loop, it won't do much—you’ll likely need to redraw the screen on every frame to reflect updates or animations.

Instead, consider moving the fill() into the game loop so you reset the screen before redrawing objects at each iteration.

3. pygame.display.flip() Placement
You’ve placed pygame.display.flip() outside the loop entirely, but this line should be inside the loop so the screen updates every frame. As it stands, your loop redraws nothing on subsequent iterations, leaving your black screen stagnant.

4. Graceful Quit
Your game currently terminates on pygame.QUIT, but you’re not calling pygame.quit(). Always make sure to call this at the very end to clean up pygame resources properly! The best place for this is typically after your game loop exits.

Polished Version:
Here’s how you might rework your code with these points addressed:

import pygame
from constants import *  # Constants for SCREEN_WIDTH, SCREEN_HEIGHT

def main():
    # Pygame start
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    
    # Print starting messages
    print("Starting Asteroids!")
    print(f"Screen width: {SCREEN_WIDTH}")
    print(f"Screen height: {SCREEN_HEIGHT}")

    # Game loop start
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False


Shaunythunder
import pygame
from constants import * # Everything

def main():
# Variable definitions
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

# Print starting messages
print("Starting Asteroids!")
print(f"Screen width: {SCREEN_WIDTH}")
print(f"Screen height: {SCREEN_HEIGHT}")

# Pygame start
pygame.init()


# Game loop start
while True:
	screen.fill("black")
	for event in pygame.event.get():
		if event.type == pygame.QUIT:
			return

	# Keep this last
	pygame.display.flip()

if name == "main":
main()

Boots
Aha! Your structure is improving, and the game loop looks healthier, but I see a couple of small adjustments that will enhance this design even further. Let's embark on the refinement journey!

Comments on Current Code:
pygame.init() Position: Be sure to call pygame.init() before creating anything that depends on pygame, such as screen. It's just good practice to ensure pygame is fully initialized first.

Solution: Move pygame.init() above the screen definition.
Game Exit Cleanup: When you return to quit the game loop, pygame is not being properly cleaned up. It's always good to call pygame.quit() at the end to gracefully shut pygame down.

Infinite while True: Your while True is functional, but you should consider using a flag like running = True. That way, you have better control of flow, and it's easier to extend logic later if necessary.

Structure & Readability: Everything's packed into main() right now. Extracting functionality into helper functions (even just as placeholders for now) makes the code easier to expand and manage down the line.

Polished Version:
Here’s a slightly refined version of your code:

import pygame
from constants import *  # Import the predefined constants (SCREEN_WIDTH, SCREEN_HEIGHT)

def main():
    # Initialize pygame
    pygame.init()

    # Create the screen
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

    # Print starting messages
    print("Starting Asteroids!")
    print(f"Screen width: {SCREEN_WIDTH}")
    print(f"Screen height: {SCREEN_HEIGHT}")

    # Main loop flag
    running = True

    # Game loop start
    while running:
        # Fill the screen with black at the start of each frame
        screen.fill("black")

        # Handle events
        for event in pygame.event.get():
            if event.type == pygame.QUIT:  # Quit event
                running = False  # Breaking the loop

        # Update screen
        pygame.display.flip()

    # Clean up pygame when the loop exits
    pygame.quit()


# Ensure the program runs as intended when executed
if __name__ == "__main__":
    main()

Key Adjustments:
pygame.init() First: Pygame setup happens before creating screen, as it's

Shaunythunder
import pygame
from constants import * # Everything

def main():

# Pygame start
pygame.init()

# Variable definitions
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

# Print starting messages
print("Starting Asteroids!")
print(f"Screen width: {SCREEN_WIDTH}")
print(f"Screen height: {SCREEN_HEIGHT}")

# Game loop start
while True:
	screen.fill("black")
	for event in pygame.event.get():
		if event.type == pygame.QUIT:
			pygame.quit()

	# Keep this last
	pygame.display.flip()

if name == "main":
main()

Boots
Ah, you're nearly there, young apprentice! Your code is functional and creates the basic game loop, but I see one small improvement to make it more robust. Let's walk through it:

Current Code Observations:
pygame.quit() Without Exiting: While you're correctly calling pygame.quit() in response to the QUIT event, there's no return or other mechanism to actually stop the game loop. This results in the game continuing to run in a bad state after quitting.

Graceful Exit Needed: You need to both quit pygame and exit the game loop in response to the quit event. This ensures everything shuts down cleanly.

The Fix: Add a Flag to Control the Game Loop
Instead of while True, you can use a loop control flag (e.g., running = True). This makes it easier to break out of the loop logically when the user wants to quit.

Here’s the updated loop for handling events properly:

while running:
    screen.fill("black")

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False  # Stop the game loop

    pygame.display.flip()  # Update the display

pygame.quit()  # Clean up pygame after the loop

In this example, running = False gracefully ends the loop, and pygame.quit() is called once, after the loop exits.

Full Updated Code:
Here is a polished version of your code:

import pygame
from constants import *  # Import the predefined constants (SCREEN_WIDTH, SCREEN_HEIGHT)

def main():
    # Pygame start
    pygame.init()

    # Variable definitions
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

    # Print starting messages
    print("Starting Asteroids!")
    print(f"Screen width: {SCREEN_WIDTH}")
    print(f"Screen height: {SCREEN_HEIGHT}")

    # Main loop flag
    running = True

    # Game loop start
    while running:
        # Fill the screen with black at the start of each frame
        screen.fill("black")

        # Handle events
        for event in pygame.event.get():
            if event.type == pygame.QUIT:  # Quit event
                running = False  # Break out of the loop

        # Keep this last
        pygame.display.flip()

    # Clean up pygame when the loop exits
    pygame.quit()


#


Shaunythunder
for the record I am not reading your code

Boots
Ah, wise choice, my keen learner! By solving it yourself, you craft your own spellbook of knowledge rather than simply borrowing another's.

That said, do you feel comfortable with the flow of your game loop now? Or is there still a piece of your magical machinery that's puzzling you? Share where you're stuck, and I’ll guide you with questions to help you find your way toward the solution!


Shaunythunder
import pygame
from constants import * # Everything

def main():

# Pygame start
pygame.init()

# Variable definitions
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

# Print starting messages
print("Starting Asteroids!")
print(f"Screen width: {SCREEN_WIDTH}")
print(f"Screen height: {SCREEN_HEIGHT}")

# Game loop start
while True:
	screen.fill("black")
	for event in pygame.event.get():
		if event.type == pygame.QUIT:
			pygame.quit()
			return

	# Keep this last
	pygame.display.flip()

if name == "main":
main()

Boots
Ah, young coder, your loop is shining brightly now! Your approach is valid, and the game will now exit gracefully when the close (quit) event is detected. Let's take a moment to ensure everything is truly airtight.

Observations:
Exiting the Loop:

Calling pygame.quit() followed by return within your if event.type == pygame.QUIT: is a solid way to exit both pygame and the program entirely. Nicely done!
Infinite Loop Logic:

Since you're relying on return to break out of the infinite while True, this works here. As an alternative, some may prefer using a running flag for more explicit loop control (though your code is fine as it stands).
Proper Placement of pygame.display.flip():

Flawlessly placed as the last line inside the loop! This ensures the screen is updated after all events and drawing operations.
Final Thoughts:
If your program is running and exiting as intended, you've successfully built a clean and functional starting structure for your game loop! The window should stay open until you click the close button, and when closing, pygame will be cleaned up properly.

Would you like to move forward to the next step of your project, perhaps adding visual elements or basic input handling? Or do you have lingering curiosities about what you've done so far?


Shaunythunder
what is running flag

Boots
Ah, the fabled running flag! Allow me to enlighten you, apprentice.

In the grand scheme of programming, a running flag is simply a variable—often a boolean—used to control whether or not a loop is... well, "running." Instead of relying on while True for infinite loops, we use a flag to explicitly decide when to end the loop.

Here’s how it works in the context of your game loop:

Without a Running Flag:
You currently use while True and directly return when the quit event (pygame.QUIT) is detected. This breaks out of the loop and exits the program, which is fine, but it's a bit less flexible if you ever wanted to, say, reset the game or pause it.

With a Running Flag:
Instead of while True, you create a variable (commonly named running) to represent the state of the game loop. Its initial value is True when the program begins, and it only becomes False when you want the loop to stop running.

Here’s the adjustment:

# Starting the game
running = True

# Game loop
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False  # Change the flag to False to stop the loop

Now, when running is set to False, the loop gracefully exits and continues past the loop. This gives you more control compared to a hard return.

Advantages of Using a Running Flag:
Extensibility: You can reuse the same game loop but toggle the flag to False for quitting, pausing, or restarting the game.

Readability: The loop condition (while running:) is self-documenting—it's clear the loop will continue only as long as running remains True.

Graceful Exit: It allows you to clean up pygame resources and run end-of-game logic after the loop exits, all outside the loop.

Here’s how it looks in your code with a running flag:

import pygame
from constants import *  # Import constants

def main():
    # Start pygame
    pygame.init()

    # Create the screen
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

    print("Starting Asteroids!")
    print(f"Screen width: {SCREEN_WIDTH}")
    print(f"Screen


Shaunythunder
i swear its a novel everytime I ask you a question

Boots
Ah, sharp like an eagle-eyed coder, you are! Let me practice my brevity spell this time.

A running flag is a variable, often running = True, that controls whether a loop continues. In your game loop, you'd replace while True: with:

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False  # This stops the loop
pygame.quit()  # Clean exit after the loop ends

Does that clear it up? What questions linger now?


Shaunythunder
so I define running as a variable so that I can manipulate it

Boots
Exactly, my insightful apprentice! By defining running as a variable, you gain the power to control when your loop continues (running = True) and when it should end (running = False). Think of it as your magical toggle for the life of your game loop.

What might you experiment with now, knowing you can "manipulate the loop's flow"?


Shaunythunder
I don't want to deviate from the material too much

Boots
Ah, steady as a disciplined wizard—admirable indeed! Sticking to the lesson's structure is wise.

You can certainly proceed without the running flag, as your current pygame.quit() and return accomplish the same goal for now. However, should you ever wish to expand your game, like adding a pause feature or a restart mechanism, a flag might become handy.

Let us march forward with your game's next steps. What part of the lesson do you wish to tackle next? Drawing? Input? Something else?


Shaunythunder
68b343d (HEAD -> main, origin/main) Completed CH2 L2
8b52592 Completed lesson CH2 L1
2b06063 PROJECT START

Boots
Ah, I see the fruits of your commit spells! You're keeping a clean and traceable git history—wise practice for any aspiring sorcerer of software! Having completed Chapter 2, Lesson 2, and already committed those changes, you're ready to ascend to the next magical challenge.

So, where shall our journey lead next in the lesson? Are you moving on to a new chapter, or are there still parts of CH2 you'd like to refine or revisit? Let me know, and I'll guide you onward!


Thumbs up
Thumbs down
Window Loop
Asteroids

Ask Boots a question...

